---
date: 2023-6-10
title: 富文本编辑器Tiptap系列教程——实时协作功能
tags:
  - tiptap
describe:
---

首先思考，如果让你实现一个富文本编辑器的的协同编辑，你能想到哪几种方案呢？

### 锁机制

大多数人第一反应都会想到利用`锁机制`去实现，比如：A 用户正在编辑某个文档时，服务端对此文档加锁，避免多人同时编辑，从而避免文档的内容冲突。
优点：简单粗暴，但会影响用户体验。

### diff-patch

第二种我们可以类比`基于 git 的版本管理`，多人编辑时利用 socket 与服务端通信，当多人编辑时服务端进行差异对比、合并，自动进行冲突处理，在通过 socket 更新其他人本地的文档。
但会出现类似 git 修改同一行，纯靠服务端无法处理，需要手动处理的问题。

这时候就引出了`OT 和 CRDT`这类专门用于**处理协同文档**的方案。那么 OT 和 CRDT 算法是如何处理上述提到的 diff-patch 的问题呢？我们来探究一下。

## 什么是 OT

全称 Operational Transformation，翻译为操作转换，即包含两个过程**操作**和**转换**。

### Operational 操作

基于 OT 的协同编辑核心是将文档的每一次修改看作是一个操作，客户端将操作发送到服务端，分为三种操作类型：

- insert

  插入字符

- delete

  删除字符

- retain

  移动光标

### Transformation 转换

转换是客户端将操作发送到服务端，服务端对操作进行转换，确保当前操作再同步到其他设备的时候得到一致的结果。转换完成后，发送到对应客户端，客户端合并操作，得到一致结果。

在富文本领域，最经典的 Operation 有 quill 的 delta 模型，通过 retain、insert、delete 三个操作完成整篇文档的描述与操作。

## 什么是 CRDT

全称 Conflict-free Replicated Data Type（无冲突复制数据类型），是一种可以在网络中的多台计算机上复制的数据结构，它主要被应用在分布式系统中，保证分布式应用的数据一致性，文档协同编辑可以理解为分布式应用的一种，它的本质是数据结构，通过数据结构的设计保证并发操作数据的最终一致性。

CRDT 于 2011 年正式被提出。 基于 CRDT 的协同编辑框架 Yjs 大概在 2015 年开源，Yjs 是专门为在 web 上构建协同应用程序而设计的。

基于状态的 CRDT 更容易设计和实现，每个 CRDT 的整个状态最终都必须传输给其他每个副本，这可能开销很大；而基于操作的 CRDT 只传输更新操作，通常很小
**全新解决方案**
**生态完整**
**完善 DEMO**

### 类型

通过[维基百科](https://zh.wikipedia.org/wiki/%E6%97%A0%E5%86%B2%E7%AA%81%E5%A4%8D%E5%88%B6%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B)对 CRDT 的介绍，

CmRDT：基于操作的 CRDT
CvRDT：基于状态的 CRDT
基于状态的 CRDT 的存储复杂性的一些下界是已知的。

Redis 是一个分布式、高可用和可扩展的内存数据库，它使用 CRDT 来实现基于开源 Redis 的全球分布式数据库，并与之完全兼容。
[Riak](https://zh.wikipedia.org/w/index.php?title=Riak&action=edit&redlink=1)是一个基于 CRDT 的分布式 NoSQL 键值数据存储。就连我们都喜欢的英雄俩萌 LOL 将 Riak CRDT 实现用于其游戏内的聊天系统，该系统可处理 750 万并发用户和每秒 11000 条信息。

## OT vs CRDT

多人协作文档：飞书、钉钉、腾讯文档、石墨、Google docs 等，都是基于 OT 实现的。那为什么不选择 CRDT，而选择难度比较大的 OT 算法呢？让我们来看一下这两种方案的优缺点吧。

### 对比

OT 通常用在文本协同编辑领域，但是一般强依赖有中心服务器，而 CRDT 更适合分布式系统，不需要中心服务器，每个客户端都可以是独立完整的版本，如 git；
OT 通过更改操作来做到这一点；
OT 会对编辑进行操作的拆分、转换，实现冲突处理的效果；
CRDT 通过更改状态来做到这一点；
基本上，CRDT 是数据结构，当使用相同的操作集进行更新时，即使这些操作以不同的顺序应用，它们始终会收敛在相同的表示形式上。
CRDT 有两种方法：基于操作和基于状态

对于富文本编辑等更高级的结构，OT 用复杂性换来了对用户预期的实现，而 CRDT 则更加关注数据结构，随着数据结构的复杂度上升，算法的时间和空间复杂度也会呈指数上升的，会带来性能上的挑战。因此，如今大多数实时协同编辑都基于 OT 算法来实现。

大厂为什么选择 OT 算法呢？

那我们的文档为什么要选用 CRDT 呢？

1. 基于 OT 实现的难度较大，没有成熟方案；
2. 基于 Yjs 的方案已经比较成熟，且 Tiptap 官方提供了基于 Yjs 的实时协作文档的实现。

### Yjs

本身是一个数据结构

两人协作，对于文档内容修改，通过中间层将 tiptap 的数据转换成 CRDT 数据；通过 CRDT 进行数据数据更新这种增量的同步，通过中间层将 CRDT 的数据转换成 tiptap 的数据，另一个协作方就能看到对方内容的更新

中间内容的更新是基于 yjs 数据结构进行的，冲突处理等核心都是 yjs 承担的，通信基于 websocket 或 webrtc，所以我们只需要简单的使用，底层的冲突处理、光标等都不需要深入学习。

**y-websocket** - 提供协同编辑时的消息通讯，包含服务端实现和前端集成的 SDK

**y-protocols** - 定义消息通讯协议，包括消息服务初始化、内容更新、鉴权、感知系统等

**y-redis** - 持久化数据到 Redis

**y-indexeddb** - 持久化数据到 IndexedDB

在上层 Yjs 支持任何大部分主流编辑器的接入，因为 Yjs 也可以理解为一套独立的数据模型，它与每种编辑器本身的数据模型是不同的，所以每种编辑器想要接入 Yjs 都必须实现一个中间绑定层，用于编辑器数据模型与 Yjs 数据模型转换，这个转换是双向的，官方目前提供了 Prosemirror、Quill、Ace 等编辑器的中间绑定层，基于 Slate 编辑器的中间绑定层是由社区开发者提供的。

#### 冲突处理

Yjs 基于数据结构层面处理冲突，比 OT 更加稳健 **（OT 如何处理？？？）**，对复杂网络的适应性更强。网络延时或离线编辑对数据结构来说，处理没有任何差异；

#### 协同列表及光标位置

Yjs 提供的 Awareness（认识;意识）模块，名如其意，让协作者能够意识到其他人的位置在哪，有效避免冲突可能性

#### 离线编辑

基于 CRDT 的内容合并，天然支持离线编辑，浏览器端做本地化存储

#### 版本历史支持

Yjs 自身提供了快照机制，保存历史版本不用保存全量数据，只是基于 Yjs 打一个快照，后续基于快照恢复历史版本

#### 系统编辑人数上限

上线人数很高
