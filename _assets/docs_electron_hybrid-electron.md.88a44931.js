import{f as a,g as e,J as n}from"./common-03e46d7f.js";const s='{"title":"前端项目在桌面端中的离线包实现及发布流程","frontmatter":{"date":"2023-08-06","title":"前端项目在桌面端中的离线包实现及发布流程","tags":["electron"],"describe":"hybrid-electron"},"headers":[{"level":2,"title":"背景","slug":"背景"},{"level":2,"title":"核心思想","slug":"核心思想"},{"level":2,"title":"解决方案","slug":"解决方案"},{"level":2,"title":"前端实现","slug":"前端实现"},{"level":2,"title":"后续优化","slug":"后续优化"},{"level":2,"title":"主要流程","slug":"主要流程"},{"level":3,"title":"离线包检查时机","slug":"离线包检查时机"},{"level":2,"title":"Quickin 接入离线包方案","slug":"quickin-接入离线包方案"},{"level":3,"title":"桌面端工程","slug":"桌面端工程"},{"level":3,"title":"网页端工程","slug":"网页端工程"},{"level":3,"title":"打包流程","slug":"打包流程"}],"relativePath":"docs/electron/hybrid-electron.md","lastUpdated":1743046188455.042}';var r={};const i=[n('<p><img src="/blog/_assets/electron-hybrid.9ea9b139.png" alt="electron-hybrid"></p><h2 id="背景"><a class="header-anchor" href="#背景" aria-hidden="true">#</a> 背景</h2><p>在使用离线包策略之前，前端的项目方案是：vue + hybird 开发，之后把开发打包完成的 dist 文件传到服务器，桌面端使用 webview 引入页面，这样的方式造成每次浏览页面会去 webview 页面里请求前端资源文件，导致效果慢。</p><h2 id="核心思想"><a class="header-anchor" href="#核心思想" aria-hidden="true">#</a> 核心思想</h2><p>将 css、图片等静态资源打包成压缩包，然后下载到客户端并解压，H5 加载时直接从本地读取静态资源文件，减少网络请求，提高速度。</p><h2 id="解决方案"><a class="header-anchor" href="#解决方案" aria-hidden="true">#</a> 解决方案</h2><p>基于上面的问题，解决如下：<strong>生成一个记录版本的管理 json 里面有版本号和文件地址</strong>，第一次打开对前端的资源文件下载到本地（文件就是上面说的 dist 里面的所有文件），第二次打开会就走离线包资源，这个版本号前端每次发版会更新这个版本号，桌面端根据这个版本号的改变下载新的包文件，然后桌面端对页面的资源请求进行拦截，拦截后使用本地的文件进行页面渲染，这样省去了包下载的过程以达到渲染页面更快。</p><h2 id="前端实现"><a class="header-anchor" href="#前端实现" aria-hidden="true">#</a> 前端实现</h2><p>离线包是用 gitlab CI 流程实现的，CI 的功能就是 install - build - delopy 就是打包部署然后上传到 OSS 指定路径，具体文件参考</p><p>运行流水线之前根据项目需要配置了变量 <img src="/blog/_assets/electron-hybrid-ci.30b7b4c9.png" alt="electron-hybrid-ci"></p><p>DEPLOYPATH 是环境变量用来判断打什么环境的包，默认是测试环境，如需打其他环境需要运行之前再次定义 DEPLOYPATH 的值</p><p><img src="/blog/_assets/electron-hybrid-ci-param.548e0c91.png" alt="electron-hybrid-ci-param"></p><p>之后点击运行流水线就会运行了，完成之后（把包文件推到了 OSS 特定目录里面）</p><p>查看文件如下： <img src="/blog/_assets/electron-hybrid-list.2b908d24.png" alt="electron-hybrid-list"></p><p>且维护一个 JSON 文件</p><p><img src="/blog/_assets/electron-hybrid-json.188eef9f.png" alt="electron-hybrid-json"></p><p>这里记载了项目文件的版本号、路径（也就是上面说的 APP 对比的版本号），APP 在进入之后请求这个文件，对比决定要不要使用本地的文件还是下载新的版本，目前这个 JSON 文件是手动维护的。</p><div class="language-bash"><pre><code>releases_private.json // 私有云\nreleases_public.json // 体验版\nreleases_dev.json // 测试环境\n</code></pre></div><div class="language-json"><pre><code><span class="token punctuation">{</span>\n  <span class="token property">&quot;status&quot;</span><span class="token operator">:</span> <span class="token number">0</span><span class="token punctuation">,</span>\n  <span class="token property">&quot;message&quot;</span><span class="token operator">:</span> <span class="token string">&quot;ok&quot;</span><span class="token punctuation">,</span>\n  <span class="token property">&quot;data&quot;</span><span class="token operator">:</span> <span class="token punctuation">{</span>\n    <span class="token property">&quot;global_enable&quot;</span><span class="token operator">:</span> <span class="token number">1</span><span class="token punctuation">,</span>\n    <span class="token property">&quot;pages&quot;</span><span class="token operator">:</span> <span class="token punctuation">[</span>\n      <span class="token punctuation">{</span>\n        <span class="token property">&quot;key&quot;</span><span class="token operator">:</span> <span class="token string">&quot;test&quot;</span><span class="token punctuation">,</span>\n        <span class="token property">&quot;version&quot;</span><span class="token operator">:</span> <span class="token string">&quot;1.0.0&quot;</span><span class="token punctuation">,</span>\n        <span class="token property">&quot;domainNames&quot;</span><span class="token operator">:</span> <span class="token punctuation">[</span><span class="token string">&quot;http://www.baidu.com&quot;</span><span class="token punctuation">]</span><span class="token punctuation">,</span>\n        <span class="token property">&quot;url&quot;</span><span class="token operator">:</span> <span class="token string">&quot;https://xxx.aliyuncs.com/apps/hy-desktop/test/test.zip&quot;</span>\n      <span class="token punctuation">}</span><span class="token punctuation">,</span>\n      <span class="token punctuation">{</span>\n        <span class="token property">&quot;key&quot;</span><span class="token operator">:</span> <span class="token string">&quot;doc&quot;</span><span class="token punctuation">,</span>\n        <span class="token property">&quot;version&quot;</span><span class="token operator">:</span> <span class="token string">&quot;1.0.3&quot;</span><span class="token punctuation">,</span>\n        <span class="token property">&quot;domainNames&quot;</span><span class="token operator">:</span> <span class="token punctuation">[</span>\n          <span class="token string">&quot;https://xxx&quot;</span><span class="token punctuation">,</span>\n          <span class="token string">&quot;https://xxx&quot;</span>\n        <span class="token punctuation">]</span><span class="token punctuation">,</span>\n        <span class="token property">&quot;url&quot;</span><span class="token operator">:</span> <span class="token string">&quot;https://xxx.aliyuncs.com/apps/hy-desktop/doc-dev/0825.zip&quot;</span>\n      <span class="token punctuation">}</span>\n    <span class="token punctuation">]</span>\n  <span class="token punctuation">}</span>\n<span class="token punctuation">}</span>\n</code></pre></div><p>更新完成后，也就完成了离线包的发布，目前离线包的发布与不离线包发布是分开的，这一系列流程走下来确实有些繁琐，也就有了第二次迭代的优化版本</p><h2 id="后续优化"><a class="header-anchor" href="#后续优化" aria-hidden="true">#</a> 后续优化</h2><ol><li>版本 JSON 文件创建、更新走接口，这也就是需要一个管理平台页面</li><li>本地的版本更新走项目的 version 版本，走 git 版本来更新</li><li>离线包与非离线包统一发布（jenkins 或者 gitlab CI/CD）</li></ol><h2 id="主要流程"><a class="header-anchor" href="#主要流程" aria-hidden="true">#</a> 主要流程</h2><ol><li>请求离线包管理配置服务，接口返回离线包下载地址和相应版本号、需要拦截的域名；</li><li>比对远端和本地离线包版本号， 按需下载相应离线包资源;</li><li>检查要更新的离线包服务是否正在使用; <ol><li>正在使用，稍后更新;</li><li>未使用，立即更新;</li></ol></li><li>加载 WebView，拦截请求，并查找本地离线包缓存，如果命中则返回缓存，未命中以域名加载;</li></ol><h3 id="离线包检查时机"><a class="header-anchor" href="#离线包检查时机" aria-hidden="true">#</a> 离线包检查时机</h3><ol><li>打开应用时</li><li>窗口隐藏时（2 分钟内仅检查一次）</li></ol><p><strong>需关注</strong></p><p>1、离线包下载失败； 2、离线包解压失败； 3、本地缓存未命中；</p><h2 id="quickin-接入离线包方案"><a class="header-anchor" href="#quickin-接入离线包方案" aria-hidden="true">#</a> Quickin 接入离线包方案</h2><ol><li>注册文件协议 registerFileProtocol需要在app.ready中触发</li><li>将离线包映射文件和地址进行替换</li></ol><h3 id="桌面端工程"><a class="header-anchor" href="#桌面端工程" aria-hidden="true">#</a> 桌面端工程</h3><h4 id="_1、404-兜底文件：目录-hybrid-packages-放入-404-html"><a class="header-anchor" href="#_1、404-兜底文件：目录-hybrid-packages-放入-404-html" aria-hidden="true">#</a> 1、404 兜底文件：目录 hybrid-packages , 放入 404.html</h4><p><img src="/blog/_assets/electron-hybrid-quickIn.d2512118.png" alt="electron-hybrid-quickIn"></p><h4 id="离线包地址：src-main-env-ts"><a class="header-anchor" href="#离线包地址：src-main-env-ts" aria-hidden="true">#</a> 离线包地址：src/main/env.ts</h4><p><img src="/blog/_assets/electron-hybrid-quickIn1.50f013bc.png" alt="electron-hybrid-quickIn"></p><h4 id="注册文件协议：src-main-protocol-manager-ts"><a class="header-anchor" href="#注册文件协议：src-main-protocol-manager-ts" aria-hidden="true">#</a> 注册文件协议：src/main/protocol-manager.ts</h4><p><img src="/blog/_assets/electron-hybrid-quickIn2.c268e60a.png" alt="electron-hybrid-quickIn"></p><h4 id="离线包映射文件和地址替换方法等：-src-main-hybrid-manager-env-hy-ts"><a class="header-anchor" href="#离线包映射文件和地址替换方法等：-src-main-hybrid-manager-env-hy-ts" aria-hidden="true">#</a> 离线包映射文件和地址替换方法等：/src/main/hybrid-manager/env-hy.ts</h4><p><img src="/blog/_assets/electron-hybrid-quickIn3.136f6bf0.png" alt="electron-hybrid-quickIn"></p><h4 id="注册混合包协议：-src-main-hybrid-manager-index-ts"><a class="header-anchor" href="#注册混合包协议：-src-main-hybrid-manager-index-ts" aria-hidden="true">#</a> 注册混合包协议：/src/main/hybrid-manager/index.ts</h4><p><img src="/blog/_assets/electron-hybrid-quickIn4.cac24a3e.png" alt="electron-hybrid-quickIn"></p><h4 id="类型文件：-src-main-hybrid-manager-ipc-hybird-d-ts"><a class="header-anchor" href="#类型文件：-src-main-hybrid-manager-ipc-hybird-d-ts" aria-hidden="true">#</a> 类型文件：/src/main/hybrid-manager/ipc-hybird.d.ts</h4><p><img src="/blog/_assets/electron-hybrid-quickIn5.03953d55.png" alt="electron-hybrid-quickIn"></p><h4 id="预加载混合文件：-src-main-hybrid-manager-preload-hy-ts"><a class="header-anchor" href="#预加载混合文件：-src-main-hybrid-manager-preload-hy-ts" aria-hidden="true">#</a> 预加载混合文件：/src/main/hybrid-manager/preload-hy.ts</h4><p><img src="/blog/_assets/electron-hybrid-quickIn6.8177d850.png" alt="electron-hybrid-quickIn"></p><h4 id="检查-下载-解压-更新：-src-main-hybrid-manager-update-ts"><a class="header-anchor" href="#检查-下载-解压-更新：-src-main-hybrid-manager-update-ts" aria-hidden="true">#</a> 检查&amp;下载&amp;解压&amp;更新：/src/main/hybrid-manager/update.ts</h4><p><img src="/blog/_assets/electron-hybrid-quickIn7.411b427e.png" alt="electron-hybrid-quickIn"></p><h4 id="新开窗口加载标签页的地址判断：-src-main-ipc-manager-browser-and-dialog-ts"><a class="header-anchor" href="#新开窗口加载标签页的地址判断：-src-main-ipc-manager-browser-and-dialog-ts" aria-hidden="true">#</a> 新开窗口加载标签页的地址判断：/src/main/ipc-manager/browser-and-dialog.ts</h4><p><img src="/blog/_assets/electron-hybrid-quickIn8.fb5cf55b.png" alt="electron-hybrid-quickIn"></p><h4 id="加一个通信方法的类型：-src-main-ipc-manager-ipc-d-ts"><a class="header-anchor" href="#加一个通信方法的类型：-src-main-ipc-manager-ipc-d-ts" aria-hidden="true">#</a> 加一个通信方法的类型：/src/main/ipc-manager/ipc.d.ts</h4><p><img src="/blog/_assets/electron-hybrid-quickIn9.b8179cc2.png" alt="electron-hybrid-quickIn"></p><h4 id="桥接处增加方法定义：-src-main-ipc-manager-preload-ts"><a class="header-anchor" href="#桥接处增加方法定义：-src-main-ipc-manager-preload-ts" aria-hidden="true">#</a> 桥接处增加方法定义：/src/main/ipc-manager/preload.ts</h4><p><img src="/blog/_assets/electron-hybrid-quickIn10.88b27cab.png" alt="electron-hybrid-quickIn"></p><h4 id="文件读写和压缩：-src-main-utils-fs-ts"><a class="header-anchor" href="#文件读写和压缩：-src-main-utils-fs-ts" aria-hidden="true">#</a> 文件读写和压缩：/src/main/utils/fs.ts</h4><p><img src="/blog/_assets/electron-hybrid-quickIn11.757a2b38.png" alt="electron-hybrid-quickIn"></p><h4 id="通信-helper-文件：-src-main-utils-ipc-helper-ts"><a class="header-anchor" href="#通信-helper-文件：-src-main-utils-ipc-helper-ts" aria-hidden="true">#</a> 通信 helper 文件：/src/main/utils/ipc-helper.ts</h4><p><img src="/blog/_assets/electron-hybrid-quickIn12.667d8a4a.png" alt="electron-hybrid-quickIn"></p><h4 id="去掉-web-环境弹窗-本地开发使用-3000-端口服务：-src-main-utils-branch-ts"><a class="header-anchor" href="#去掉-web-环境弹窗-本地开发使用-3000-端口服务：-src-main-utils-branch-ts" aria-hidden="true">#</a> 去掉 web 环境弹窗 &amp; 本地开发使用 3000 端口服务：/src/main/utils/branch.ts</h4><p><img src="/blog/_assets/electron-hybrid-quickIn13.c7eb69be.png" alt="electron-hybrid-quickIn"></p><h4 id="主窗口非本地环境下两个时机检测离线包：-src-main-window-manager-main-window-ts"><a class="header-anchor" href="#主窗口非本地环境下两个时机检测离线包：-src-main-window-manager-main-window-ts" aria-hidden="true">#</a> 主窗口非本地环境下两个时机检测离线包：/src/main/window-manager/main-window.ts</h4><p><img src="/blog/_assets/electron-hybrid-quickIn14.3ee0572d.png" alt="electron-hybrid-quickIn"></p><h4 id="使用新增的-r2m2r-通信方法进行标签域名替换判断：-src-render-views-muti-tabs-useviews-ts"><a class="header-anchor" href="#使用新增的-r2m2r-通信方法进行标签域名替换判断：-src-render-views-muti-tabs-useviews-ts" aria-hidden="true">#</a> 使用新增的 R2M2R 通信方法进行标签域名替换判断：/src/render/views/muti-tabs/useViews.ts</h4><p><img src="/blog/_assets/electron-hybrid-quickIn15.4f7e72ec.png" alt="electron-hybrid-quickIn"></p><h4 id="桌面端环境：按照原本的-6-个环境使用"><a class="header-anchor" href="#桌面端环境：按照原本的-6-个环境使用" aria-hidden="true">#</a> 桌面端环境：按照原本的 6 个环境使用</h4><p><img src="/blog/_assets/electron-hybrid-quickIn16.0810c66f.png" alt="electron-hybrid-quickIn"></p><p>打包流程：与原本一致 上线流程：与原本一致（注意版本控制即可）</p><h3 id="网页端工程"><a class="header-anchor" href="#网页端工程" aria-hidden="true">#</a> 网页端工程</h3><h4 id="打包指令修改，输出包不使用-viteenv：package-json"><a class="header-anchor" href="#打包指令修改，输出包不使用-viteenv：package-json" aria-hidden="true">#</a> 打包指令修改，输出包不使用 viteEnv：package.json</h4><p><img src="/blog/_assets/electron-hybrid-quickIn17.5bfc50b2.png" alt="electron-hybrid-quickIn"></p><h4 id="用到-import-meta-env-的地方，替换为从桌面端获取环境"><a class="header-anchor" href="#用到-import-meta-env-的地方，替换为从桌面端获取环境" aria-hidden="true">#</a> 用到 import.meta.env 的地方，替换为从桌面端获取环境</h4><p><img src="/blog/_assets/electron-hybrid-quickIn18.a7a6a069.png" alt="electron-hybrid-quickIn"></p><h4 id="新增配置文件，用于合理映射和线上环境兜底"><a class="header-anchor" href="#新增配置文件，用于合理映射和线上环境兜底" aria-hidden="true">#</a> 新增配置文件，用于合理映射和线上环境兜底</h4><p><img src="/blog/_assets/electron-hybrid-quickIn19.369a7bf8.png" alt="electron-hybrid-quickIn"></p><h4 id="单独调用了-vite-的-mode-或者-node-env-的地方，换成来自桌面端的环境名称判断，也是-viteenv-允许兜底使用"><a class="header-anchor" href="#单独调用了-vite-的-mode-或者-node-env-的地方，换成来自桌面端的环境名称判断，也是-viteenv-允许兜底使用" aria-hidden="true">#</a> 单独调用了 vite 的 mode 或者 NODE_ENV 的地方，换成来自桌面端的环境名称判断，也是 ViteEnv 允许兜底使用</h4><p><img src="/blog/_assets/electron-hybrid-quickIn20.ca4bb2a6.png" alt="electron-hybrid-quickIn"></p><h4 id="重定向自动登录流程-改为-非阻塞自动登录流程，token-和-im-id-直接传过去，然后异步自动登录，目标页面优先执行"><a class="header-anchor" href="#重定向自动登录流程-改为-非阻塞自动登录流程，token-和-im-id-直接传过去，然后异步自动登录，目标页面优先执行" aria-hidden="true">#</a> 重定向自动登录流程 改为 非阻塞自动登录流程，token 和 im_id 直接传过去，然后异步自动登录，目标页面优先执行</h4><p><img src="/blog/_assets/electron-hybrid-quickIn21.827e86b5.png" alt="electron-hybrid-quickIn"></p><h4 id="路由前置守卫需要取下来关键参数-token、im-id-，并存起来，然后再去-next-，这样可以保证页面接口正常请求，配合第五步实现非阻塞流程"><a class="header-anchor" href="#路由前置守卫需要取下来关键参数-token、im-id-，并存起来，然后再去-next-，这样可以保证页面接口正常请求，配合第五步实现非阻塞流程" aria-hidden="true">#</a> 路由前置守卫需要取下来关键参数(token、im_id)，并存起来，然后再去 next()，这样可以保证页面接口正常请求，配合第五步实现非阻塞流程</h4><p><img src="/blog/_assets/electron-hybrid-quickIn22.b2e7fab3.png" alt="electron-hybrid-quickIn"></p><p>页面端环境：主要跟随桌面端环境走，名称和内容也要对应上，这样才可以保证登录状态已经服务端鉴权有效</p><p><img src="/blog/_assets/electron-hybrid-quickIn23.716fe0af.png" alt="electron-hybrid-quickIn"></p><h3 id="打包流程"><a class="header-anchor" href="#打包流程" aria-hidden="true">#</a> 打包流程</h3><ul><li><p>OSS 离线包方案：</p><ul><li>命令：npm run build</li><li>压缩：dist 压缩为+0.0.1 版本包（例：v1.8.2.zip）</li><li>上传：手动拖入 OSS 对应环境的目录（别拖错位置了）</li><li>配置文件：修改 OSS 上对应环境的 version 版本和 url 的版本</li></ul></li><li><p>网页端兜底方案：</p><ul><li>打包：Jenkins 运行任务（注意 jenkins 命令修改）</li><li>描述：只有一个 build，不区分环境，环境跟随调用方</li></ul></li></ul>',83)];r.render=function(n,s,r,t,c,o){return a(),e("div",null,i)};export{s as __pageData,r as default};
