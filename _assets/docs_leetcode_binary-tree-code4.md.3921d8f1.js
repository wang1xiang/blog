import{f as n,g as s,J as a}from"./common-03e46d7f.js";const p='{"title":"跟着卡哥学算法Day 17：二叉树常见题目5","frontmatter":{"date":"2025-02-28","title":"跟着卡哥学算法Day 17：二叉树常见题目5","tags":["leetcode"],"describe":"二叉树常见题目5"},"headers":[{"level":2,"title":"654.最大二叉树 🌟🌟","slug":"_654-最大二叉树-🌟🌟"},{"level":3,"title":"题目描述","slug":"题目描述"},{"level":3,"title":"解题思路","slug":"解题思路"},{"level":2,"title":"617.合并二叉树 🌟","slug":"_617-合并二叉树-🌟"},{"level":3,"title":"题目描述","slug":"题目描述-2"},{"level":3,"title":"解题思路","slug":"解题思路-2"},{"level":2,"title":"700.二叉搜索树中的搜索 🌟","slug":"_700-二叉搜索树中的搜索-🌟"},{"level":3,"title":"题目描述","slug":"题目描述-3"},{"level":3,"title":"解题思路","slug":"解题思路-3"},{"level":2,"title":"98.验证二叉搜索树 🌟🌟","slug":"_98-验证二叉搜索树-🌟🌟"},{"level":3,"title":"题目描述","slug":"题目描述-4"},{"level":3,"title":"解题思路","slug":"解题思路-4"},{"level":3,"title":"代码","slug":"代码"}],"relativePath":"docs/leetcode/binary-tree-code4.md","lastUpdated":1742177050168.4553}';var t={};const o=[a('<h2 id="_654-最大二叉树-🌟🌟"><a class="header-anchor" href="#_654-最大二叉树-🌟🌟" aria-hidden="true">#</a> 654.最大二叉树 🌟🌟</h2><p><a href="https://leetcode.cn/problems/maximum-binary-tree/" target="_blank" rel="noopener noreferrer">力扣链接</a> 🌟🌟</p><h3 id="题目描述"><a class="header-anchor" href="#题目描述" aria-hidden="true">#</a> 题目描述</h3><p>给定一个不含重复元素的整数数组。一个以此数组构建的最大二叉树定义如下：</p><ul><li>二叉树的根是数组中的最大元素。</li><li>左子树是通过数组中最大值左边部分构造出的最大二叉树。</li><li>右子树是通过数组中最大值右边部分构造出的最大二叉树。</li></ul><p>通过给定的数组构建最大二叉树，并且输出这个树的根节点。</p><p>示例 ：</p><p>输入：[3, 2, 1, 6, 0, 5]</p><div class="language-js"><pre><code><span class="token comment">// 输出 树根节点</span>\n<span class="token comment">//       6</span>\n<span class="token comment">//      / \\</span>\n<span class="token comment">//     3   5</span>\n<span class="token comment">//     \\   /</span>\n<span class="token comment">//     2  0</span>\n<span class="token comment">//     \\</span>\n<span class="token comment">//     1</span>\n</code></pre></div><h3 id="解题思路"><a class="header-anchor" href="#解题思路" aria-hidden="true">#</a> 解题思路</h3><ul><li>关键：构造二叉树一定是<strong>前序遍历</strong>，先有根节点，递归构造左右子树</li></ul><p>递归三部曲：</p><ol><li><p>明确递归函数的参数和返回值</p><ul><li>参数 1：传入的数组</li><li>返回值：根节点</li></ul></li><li><p>明确终止条件</p><ul><li>数组长度为 1 时，就是叶子节点，直接构造叶子节点并返回</li></ul></li><li><p>确定单层递归逻辑</p><ul><li><p>找最大值和对应下标，值用来构造根节点，下标用来分割数组（左右子树）</p><div class="language-js"><pre><code><span class="token keyword">let</span> max <span class="token operator">=</span> nums<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span>\n<span class="token keyword">let</span> maxIndex <span class="token operator">=</span> <span class="token number">0</span>\n<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> nums<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  <span class="token keyword">if</span> <span class="token punctuation">(</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">&gt;</span> max<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    max <span class="token operator">=</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span>\n    maxIndex <span class="token operator">=</span> i\n  <span class="token punctuation">}</span>\n<span class="token punctuation">}</span>\n<span class="token keyword">const</span> root <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">TreeNode</span><span class="token punctuation">(</span>max<span class="token punctuation">)</span>\n</code></pre></div></li><li><p>分割数组</p></li><li><p>用左区间构造左子树</p><div class="language-js"><pre><code>root<span class="token punctuation">.</span>left <span class="token operator">=</span> <span class="token function">constructMaximumBinaryTree</span><span class="token punctuation">(</span>nums<span class="token punctuation">.</span><span class="token function">slice</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> maxIndex<span class="token punctuation">)</span><span class="token punctuation">)</span>\n</code></pre></div></li><li><p>用右区间构造右子树</p><div class="language-js"><pre><code>root<span class="token punctuation">.</span>right <span class="token operator">=</span> <span class="token function">constructMaximumBinaryTree</span><span class="token punctuation">(</span>nums<span class="token punctuation">.</span><span class="token function">slice</span><span class="token punctuation">(</span>maxIndex <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span>\n</code></pre></div></li></ul></li></ol><div class="language-js"><pre><code><span class="token keyword">function</span> <span class="token function">constructMaximumBinaryTree</span><span class="token punctuation">(</span><span class="token parameter">nums</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>nums<span class="token punctuation">.</span>length<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token keyword">null</span>\n\n  <span class="token keyword">const</span> max <span class="token operator">=</span> num<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span>\n  <span class="token keyword">const</span> maxIndex <span class="token operator">=</span> <span class="token number">0</span>\n  <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> i<span class="token punctuation">;</span> i <span class="token operator">&lt;</span> nums<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token keyword">if</span> <span class="token punctuation">(</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">&gt;</span> max<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n      max <span class="token operator">=</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span>\n      maxIndex <span class="token operator">=</span> i\n    <span class="token punctuation">}</span>\n  <span class="token punctuation">}</span>\n\n  <span class="token keyword">const</span> root <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">TreeNode</span><span class="token punctuation">(</span>max<span class="token punctuation">)</span>\n  root<span class="token punctuation">.</span>left <span class="token operator">=</span> <span class="token function">constructMaximumBinaryTree</span><span class="token punctuation">(</span>nums<span class="token punctuation">.</span><span class="token function">slice</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> maxIndex<span class="token punctuation">)</span><span class="token punctuation">)</span>\n  root<span class="token punctuation">.</span>right <span class="token operator">=</span> <span class="token function">constructMaximumBinaryTree</span><span class="token punctuation">(</span>nums<span class="token punctuation">.</span><span class="token function">slice</span><span class="token punctuation">(</span>maxIndex <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span>\n\n  <span class="token keyword">return</span> root\n<span class="token punctuation">}</span>\n</code></pre></div><h2 id="_617-合并二叉树-🌟"><a class="header-anchor" href="#_617-合并二叉树-🌟" aria-hidden="true">#</a> 617.合并二叉树 🌟</h2><p><a href="https://leetcode.cn/problems/merge-two-binary-trees/" target="_blank" rel="noopener noreferrer">力扣链接</a> 🌟</p><h3 id="题目描述-2"><a class="header-anchor" href="#题目描述-2" aria-hidden="true">#</a> 题目描述</h3><p>给定两个二叉树，想象当你将它们中的一个覆盖到另一个上时，两个二叉树的一些节点便会重叠。</p><p>你需要将他们合并为一个新的二叉树。合并的规则是如果两个节点重叠，那么将他们的值相加作为节点合并后的新值，否则不为 NULL 的节点将直接作为新二叉树的节点。</p><p>示例:</p><div class="language-js"><pre><code><span class="token comment">//     Tree 1                     Tree 2</span>\n<span class="token comment">//       1                         2</span>\n<span class="token comment">//      / \\                       / \\</span>\n<span class="token comment">//     3  2                      1   3</span>\n<span class="token comment">//    /                           \\   \\</span>\n<span class="token comment">//   5                            4    7</span>\n\n<span class="token comment">// 合并后</span>\n<span class="token comment">//     3</span>\n<span class="token comment">//    / \\</span>\n<span class="token comment">//   4  5</span>\n<span class="token comment">//  /\\   \\</span>\n<span class="token comment">// 5 4   7</span>\n</code></pre></div><h3 id="解题思路-2"><a class="header-anchor" href="#解题思路-2" aria-hidden="true">#</a> 解题思路</h3><p>采用<strong>前序遍历</strong>最直观，与遍历一个树的逻辑一样</p><h4 id="递归"><a class="header-anchor" href="#递归" aria-hidden="true">#</a> 递归</h4><p>递归三部曲：</p><ol><li><p>确定递归函数的参数和返回值</p><ul><li>参数 1：Tree 1</li><li>参数 2：Tree 2</li><li>返回值：新二叉树的 root</li></ul></li><li><p>确定终止条件</p><p>遍历同一个节点时，Tree 1 为空，返回 Tree 2；Tree 2 为空，返回 Tree 1</p><div class="language-js"><pre><code><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>root1<span class="token punctuation">)</span> <span class="token keyword">return</span> root2\n<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>root2<span class="token punctuation">)</span> <span class="token keyword">return</span> root1\n</code></pre></div></li><li><p>确定单层递归逻辑</p><ul><li>将两个树节点值相加 <code>root.val += root2.val</code></li><li>递归处理左子树</li><li>递归处理右子树</li></ul></li></ol><div class="language-js"><pre><code><span class="token keyword">function</span> <span class="token function">mergeTrees</span><span class="token punctuation">(</span><span class="token parameter">root1<span class="token punctuation">,</span> root2</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>root1<span class="token punctuation">)</span> <span class="token keyword">return</span> root2\n  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>root2<span class="token punctuation">)</span> <span class="token keyword">return</span> root1\n\n  root1<span class="token punctuation">.</span>val <span class="token operator">+=</span> root2<span class="token punctuation">.</span>val\n  root1<span class="token punctuation">.</span>left <span class="token operator">=</span> <span class="token function">mergeTrees</span><span class="token punctuation">(</span>root1<span class="token punctuation">.</span>left<span class="token punctuation">,</span> root2<span class="token punctuation">.</span>left<span class="token punctuation">)</span>\n  root1<span class="token punctuation">.</span>right <span class="token operator">=</span> <span class="token function">mergeTrees</span><span class="token punctuation">(</span>root1<span class="token punctuation">.</span>right<span class="token punctuation">,</span> root2<span class="token punctuation">.</span>right<span class="token punctuation">)</span>\n\n  <span class="token keyword">return</span> root1\n<span class="token punctuation">}</span>\n</code></pre></div><h4 id="迭代"><a class="header-anchor" href="#迭代" aria-hidden="true">#</a> 迭代</h4><p>步骤：</p><ol><li>初始化队列：root1 和 root2 进入队列</li><li>遍历队列：弹出 root1 和 root2，累加 <code>root1.val += root2.val</code></li><li>压入左子节点：同时压入 root1.left 和 root2.left，都不为 null 时</li><li>压入右子节点：同时压入 root1.right 和 root2.right，都不为 null 时</li><li><strong>注意</strong>：如果 root1.left 或 root1.right 为 null 时，直接将 root2.left 或 root2.right 替换为 root1.left 或 root1.right</li></ol><div class="language-js"><pre><code><span class="token keyword">function</span> <span class="token function">mergeTrees</span><span class="token punctuation">(</span><span class="token parameter">root1<span class="token punctuation">,</span> root2</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>root1<span class="token punctuation">)</span> <span class="token keyword">return</span> root2\n  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>root2<span class="token punctuation">)</span> <span class="token keyword">return</span> root1\n\n  <span class="token keyword">const</span> queue <span class="token operator">=</span> <span class="token punctuation">[</span>root1<span class="token punctuation">,</span> root2<span class="token punctuation">]</span>\n  <span class="token keyword">while</span> <span class="token punctuation">(</span>queue<span class="token punctuation">.</span>length<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token keyword">const</span> node1 <span class="token operator">=</span> queue<span class="token punctuation">.</span><span class="token function">shift</span><span class="token punctuation">(</span><span class="token punctuation">)</span>\n    <span class="token keyword">const</span> node2 <span class="token operator">=</span> queue<span class="token punctuation">.</span><span class="token function">shift</span><span class="token punctuation">(</span><span class="token punctuation">)</span>\n\n    node1<span class="token punctuation">.</span>val <span class="token operator">+=</span> node2<span class="token punctuation">.</span>val\n\n    <span class="token keyword">if</span> <span class="token punctuation">(</span>node1<span class="token punctuation">.</span>left <span class="token operator">&amp;&amp;</span> node2<span class="token punctuation">.</span>left<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n      queue<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>node1<span class="token punctuation">.</span>left<span class="token punctuation">)</span>\n      queue<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>node2<span class="token punctuation">.</span>left<span class="token punctuation">)</span>\n    <span class="token punctuation">}</span>\n    <span class="token keyword">if</span> <span class="token punctuation">(</span>node1<span class="token punctuation">.</span>right <span class="token operator">&amp;&amp;</span> node2<span class="token punctuation">.</span>right<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n      queue<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>node1<span class="token punctuation">.</span>right<span class="token punctuation">)</span>\n      queue<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>node2<span class="token punctuation">.</span>right<span class="token punctuation">)</span>\n    <span class="token punctuation">}</span>\n    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>node1<span class="token punctuation">.</span>left <span class="token operator">&amp;&amp;</span> node2<span class="token punctuation">.</span>left<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n      node1<span class="token punctuation">.</span>left <span class="token operator">=</span> node2<span class="token punctuation">.</span>left\n    <span class="token punctuation">}</span>\n    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>node1<span class="token punctuation">.</span>right <span class="token operator">&amp;&amp;</span> node2<span class="token punctuation">.</span>right<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n      node1<span class="token punctuation">.</span>right <span class="token operator">=</span> node2<span class="token punctuation">.</span>right\n    <span class="token punctuation">}</span>\n  <span class="token punctuation">}</span>\n  <span class="token keyword">return</span> root1\n<span class="token punctuation">}</span>\n</code></pre></div><h2 id="_700-二叉搜索树中的搜索-🌟"><a class="header-anchor" href="#_700-二叉搜索树中的搜索-🌟" aria-hidden="true">#</a> 700.二叉搜索树中的搜索 🌟</h2><p><a href="https://leetcode.cn/problems/search-in-a-binary-search-tree/" target="_blank" rel="noopener noreferrer">力扣链接</a> 🌟</p><h3 id="题目描述-3"><a class="header-anchor" href="#题目描述-3" aria-hidden="true">#</a> 题目描述</h3><p>给定二叉搜索树（BST）的根节点和一个值。 你需要在 BST 中找到节点值等于给定值的节点。 返回以该节点为根的子树。 如果节点不存在，则返回 NULL。</p><p>示例:</p><div class="language-js"><pre><code><span class="token comment">// 给定二叉搜索树:</span>\n<span class="token comment">//       4</span>\n<span class="token comment">//      / \\</span>\n<span class="token comment">//     2  7</span>\n<span class="token comment">//    / \\</span>\n<span class="token comment">//   1  3</span>\n<span class="token comment">// 和值：2</span>\n\n<span class="token comment">// 返回</span>\n<span class="token comment">//     2</span>\n<span class="token comment">//    / \\</span>\n<span class="token comment">//   1  3</span>\n</code></pre></div><h3 id="解题思路-3"><a class="header-anchor" href="#解题思路-3" aria-hidden="true">#</a> 解题思路</h3><p>二叉搜索树：根节点比左子树所有节点的值都大、比右子树所有节点的值都小，同时左右子树都是二叉搜索树</p><h4 id="递归-2"><a class="header-anchor" href="#递归-2" aria-hidden="true">#</a> 递归</h4><p>递归三部曲：</p><ol><li><p>确定递归函数的参数和返回值</p><ul><li>参数 1：根节点</li><li>参数 2：要搜索的值</li><li>返回值：搜索的值所在的节点</li></ul></li><li><p>确定终止条件</p><p>如果 root 为 null 或者找到数值了，返回 root</p><div class="language-js"><pre><code><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>root <span class="token operator">||</span> node<span class="token punctuation">.</span>val <span class="token operator">===</span> val<span class="token punctuation">)</span> <span class="token keyword">return</span> root\n</code></pre></div></li><li><p>确定单层递归逻辑</p><p><strong>这里与普通二叉树的递归不同</strong></p><ul><li>若目标值小于当前节点值，递归搜索左子树</li><li>若目标值大于当前节点值，递归搜索右子树</li></ul></li></ol><div class="language-js"><pre><code><span class="token keyword">function</span> <span class="token function">searchBST</span><span class="token punctuation">(</span><span class="token parameter">root<span class="token punctuation">,</span> val</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>root <span class="token operator">||</span> root<span class="token punctuation">.</span>val <span class="token operator">===</span> val<span class="token punctuation">)</span> <span class="token keyword">return</span> root\n\n  <span class="token keyword">if</span> <span class="token punctuation">(</span>root<span class="token punctuation">.</span>val <span class="token operator">&gt;</span> val<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token keyword">return</span> <span class="token function">searchBST</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>left<span class="token punctuation">,</span> val<span class="token punctuation">)</span>\n  <span class="token punctuation">}</span>\n  <span class="token keyword">if</span> <span class="token punctuation">(</span>root<span class="token punctuation">.</span>val <span class="token operator">&lt;</span> val<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token keyword">return</span> <span class="token function">searchBST</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>right<span class="token punctuation">,</span> val<span class="token punctuation">)</span>\n  <span class="token punctuation">}</span>\n<span class="token punctuation">}</span>\n</code></pre></div><h4 id="迭代-2"><a class="header-anchor" href="#迭代-2" aria-hidden="true">#</a> 迭代</h4><ul><li>使用循环代替递归，从根节点开始遍历</li><li>根据当前节点值与目标值的比较结果，移动到左子节点或右子节点</li><li>找到匹配的节点时立即返回，否则遍历结束返回 null</li></ul><div class="language-js"><pre><code><span class="token keyword">function</span> <span class="token function">searchBST</span><span class="token punctuation">(</span><span class="token parameter">root<span class="token punctuation">,</span> val</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  <span class="token keyword">while</span> <span class="token punctuation">(</span>root<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token keyword">if</span> <span class="token punctuation">(</span>root<span class="token punctuation">.</span>val <span class="token operator">===</span> val<span class="token punctuation">)</span> <span class="token keyword">return</span> root\n\n    <span class="token keyword">if</span> <span class="token punctuation">(</span>root<span class="token punctuation">.</span>val <span class="token operator">&gt;</span> val<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n      root <span class="token operator">=</span> root<span class="token punctuation">.</span>left\n    <span class="token punctuation">}</span>\n    <span class="token keyword">if</span> <span class="token punctuation">(</span>root<span class="token punctuation">.</span>val <span class="token operator">&lt;</span> val<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n      root <span class="token operator">=</span> root<span class="token punctuation">.</span>right\n    <span class="token punctuation">}</span>\n  <span class="token punctuation">}</span>\n  <span class="token keyword">return</span> root\n<span class="token punctuation">}</span>\n</code></pre></div><h2 id="_98-验证二叉搜索树-🌟🌟"><a class="header-anchor" href="#_98-验证二叉搜索树-🌟🌟" aria-hidden="true">#</a> 98.验证二叉搜索树 🌟🌟</h2><p><a href="https://leetcode.cn/problems/validate-binary-search-tree/description/" target="_blank" rel="noopener noreferrer">力扣链接</a> 🌟🌟</p><h3 id="题目描述-4"><a class="header-anchor" href="#题目描述-4" aria-hidden="true">#</a> 题目描述</h3><p>给定一个二叉树，判断其是否是一个有效的二叉搜索树。</p><p>假设一个二叉搜索树具有如下特征：</p><ul><li>节点的左子树只包含小于当前节点的数。</li><li>节点的右子树只包含大于当前节点的数。</li><li>所有左子树和右子树自身必须也是二叉搜索树。</li></ul><div class="language-js"><pre><code><span class="token comment">//       2</span>\n<span class="token comment">//      / \\</span>\n<span class="token comment">//     1  3</span>\n<span class="token comment">// 输出 true</span>\n</code></pre></div><h3 id="解题思路-4"><a class="header-anchor" href="#解题思路-4" aria-hidden="true">#</a> 解题思路</h3><p>常见错误：<strong>只比较每个节点与其左右节点的关系，没有考虑全局上节点的关系</strong>，如：某个右子树的左节点可能比父节点小，同时比根节点小</p><p>需要一个区间[min, max]来确定当前节点值是否在这个区间</p><h4 id="递归-3"><a class="header-anchor" href="#递归-3" aria-hidden="true">#</a> 递归</h4><p>三部曲</p><ol><li><p>确定递归函数的参数和返回值</p><ul><li>参数 1：根节点</li><li>参数 2：最小值，从根节点开始为-Infinity，右子树需要不断更新最小值为当前值</li><li>参数 3：最大值，从节点为最大值，左子树需要不断更新最大值为当前值</li><li>返回值：根节点</li></ul></li><li><p>确定终止条件</p><ul><li>根节点为 null 时，返回 true</li><li>当前值不在[min, max]区间时，返回 false</li></ul></li><li><p>确定单层递归逻辑</p><ul><li>递归左右子树</li></ul></li></ol><h3 id="代码"><a class="header-anchor" href="#代码" aria-hidden="true">#</a> 代码</h3><div class="language-js"><pre><code><span class="token keyword">function</span> <span class="token function">isValidBST</span><span class="token punctuation">(</span><span class="token parameter">root</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  <span class="token keyword">const</span> <span class="token function-variable function">traverse</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token parameter">root<span class="token punctuation">,</span> min<span class="token punctuation">,</span> max</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>\n    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>root<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token boolean">true</span>\n    <span class="token keyword">if</span> <span class="token punctuation">(</span>root<span class="token punctuation">.</span>val <span class="token operator">&lt;=</span> min <span class="token operator">||</span> root<span class="token punctuation">.</span>val <span class="token operator">&gt;=</span> max<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token boolean">false</span>\n\n    <span class="token keyword">return</span> <span class="token punctuation">(</span>\n      <span class="token function">traverse</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>left<span class="token punctuation">,</span> min<span class="token punctuation">,</span> root<span class="token punctuation">.</span>val<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token function">traverse</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>right<span class="token punctuation">,</span> root<span class="token punctuation">.</span>val<span class="token punctuation">,</span> max<span class="token punctuation">)</span>\n    <span class="token punctuation">)</span>\n  <span class="token punctuation">}</span>\n\n  <span class="token keyword">return</span> <span class="token function">traverse</span><span class="token punctuation">(</span>root<span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">Infinity</span><span class="token punctuation">,</span> <span class="token number">Infinity</span><span class="token punctuation">)</span>\n<span class="token punctuation">}</span>\n</code></pre></div><h4 id="迭代-3"><a class="header-anchor" href="#迭代-3" aria-hidden="true">#</a> 迭代</h4><p>思路：</p><ol><li>使用栈存储节点及其允许的上下界</li><li>遍历时检查节点值是否在范围内，并更新子节点的范围</li></ol><div class="language-js"><pre><code><span class="token keyword">function</span> <span class="token function">isValidBST</span><span class="token punctuation">(</span><span class="token parameter">root</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>root<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token boolean">true</span>\n\n  <span class="token keyword">const</span> stack <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">[</span>root<span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">Infinity</span><span class="token punctuation">,</span> <span class="token number">Infinity</span><span class="token punctuation">]</span><span class="token punctuation">]</span>\n\n  <span class="token keyword">while</span> <span class="token punctuation">(</span>stack<span class="token punctuation">.</span>length<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token keyword">const</span> <span class="token punctuation">[</span>node<span class="token punctuation">,</span> min<span class="token punctuation">,</span> max<span class="token punctuation">]</span> <span class="token operator">=</span> stack<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span>\n    <span class="token keyword">if</span> <span class="token punctuation">(</span>node<span class="token punctuation">.</span>val <span class="token operator">&lt;=</span> min <span class="token operator">||</span> node<span class="token punctuation">.</span>val <span class="token operator">&gt;=</span> max<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token boolean">false</span>\n    node<span class="token punctuation">.</span>left <span class="token operator">&amp;&amp;</span> stack<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token punctuation">[</span>node<span class="token punctuation">.</span>left<span class="token punctuation">,</span> min<span class="token punctuation">,</span> node<span class="token punctuation">.</span>val<span class="token punctuation">]</span><span class="token punctuation">)</span>\n    node<span class="token punctuation">.</span>right <span class="token operator">&amp;&amp;</span> stack<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token punctuation">[</span>node<span class="token punctuation">.</span>right<span class="token punctuation">,</span> node<span class="token punctuation">.</span>val<span class="token punctuation">,</span> max<span class="token punctuation">]</span><span class="token punctuation">)</span>\n  <span class="token punctuation">}</span>\n\n  <span class="token keyword">return</span> <span class="token boolean">true</span>\n<span class="token punctuation">}</span>\n</code></pre></div>',65)];t.render=function(a,p,t,e,c,l){return n(),s("div",null,o)};export{p as __pageData,t as default};
