import{f as e,g as o,J as n}from"./common-03e46d7f.js";const a='{"title":"prosemirror-tables 源码解读","frontmatter":{"date":"2023-03-07","title":"prosemirror-tables 源码解读","tags":["tool","prosemirror"],"describe":"学习prosemirror-tables使用及阅读源码的过程"},"headers":[{"level":2,"title":"为什么写这篇文章","slug":"为什么写这篇文章"},{"level":2,"title":"名次解释","slug":"名次解释"},{"level":3,"title":"document","slug":"document"},{"level":3,"title":"Schema","slug":"schema"},{"level":3,"title":"Node","slug":"node"},{"level":3,"title":"Mark","slug":"mark"},{"level":3,"title":"State","slug":"state"},{"level":3,"title":"Transaction","slug":"transaction"},{"level":3,"title":"View","slug":"view"},{"level":3,"title":"Plugin","slug":"plugin"},{"level":3,"title":"Commands","slug":"commands"},{"level":3,"title":"Decorations","slug":"decorations"},{"level":3,"title":"ResolvedPos","slug":"resolvedpos"},{"level":3,"title":"Selection","slug":"selection"},{"level":3,"title":"Slice","slug":"slice"},{"level":2,"title":"源码目录","slug":"源码目录"},{"level":3,"title":"cellselection.ts","slug":"cellselection-ts"},{"level":3,"title":"columnresizing.ts","slug":"columnresizing-ts"},{"level":3,"title":"commands.ts","slug":"commands-ts"},{"level":3,"title":"copypaste.ts","slug":"copypaste-ts"},{"level":3,"title":"fixtables.ts","slug":"fixtables-ts"},{"level":3,"title":"index.ts","slug":"index-ts"},{"level":3,"title":"input.ts","slug":"input-ts"},{"level":3,"title":"schema.ts","slug":"schema-ts"},{"level":3,"title":"tablemap.ts","slug":"tablemap-ts"},{"level":3,"title":"tableview.ts","slug":"tableview-ts"},{"level":3,"title":"util.ts","slug":"util-ts"}],"relativePath":"docs/tool/prosemirror-tables.md","lastUpdated":1742891324730.5251}';var s={};const t=[n('<h2 id="为什么写这篇文章"><a class="header-anchor" href="#为什么写这篇文章" aria-hidden="true">#</a> 为什么写这篇文章</h2><p>公司使用<a href="https://tiptap.dev/" target="_blank" rel="noopener noreferrer">tiptap</a>富文本编辑器，在<code>tiptap</code>的官网有这么一段话<code>Tiptap is a headless wrapper around [ProseMirror](https://prosemirror.net/)</code>，这里的<code>headless wrapper</code>意思是“无头编辑器”，指的是不提供任何<code>UI</code>样式，完全自由的定制任何想要的<code>UI</code>，特别适合二次开发。</p><p>而<code>tiptap</code>是对<a href="https://prosemirror.net/" target="_blank" rel="noopener noreferrer">prosemirror</a>的封装，在<code>prosemirror</code>的基础上提供了更友好的<code>API</code>、模块封装以及将<code>MVVM</code>的接入封装在框架内部，适用于各种<a href="https://tiptap.dev/installation" target="_blank" rel="noopener noreferrer">流行框架</a>，使开发者更容易上手。</p><p><code>tiptap</code>提供大量官方<a href="https://tiptap.dev/extensions" target="_blank" rel="noopener noreferrer">扩展</a>，像本文介绍的<a href="https://github.com/ProseMirror/prosemirror-tables" target="_blank" rel="noopener noreferrer">prosemirror-tabls</a>，但官方的毕竟是官方，一些样式或基本功能的改动，就必须要通过修改源码的方式实现。</p><h2 id="名次解释"><a class="header-anchor" href="#名次解释" aria-hidden="true">#</a> 名次解释</h2><blockquote><p>PS：理解完概念再往下看，不然容易一脸懵</p></blockquote><h3 id="document"><a class="header-anchor" href="#document" aria-hidden="true">#</a> <a href="https://prosemirror.net/docs/guide/#doc" target="_blank" rel="noopener noreferrer">document</a></h3><p>用于表示<code>ProseMirror</code>的整个文档，使用<code>editor.view.state.doc</code>引用，<code>ProseMirror</code>定义自己的数据结构来存储<code>document</code>内容，通过输出可以看到<code>document</code>是一个<code>Node</code>类型，包含<code>content</code>元素，是一个<a href="https://prosemirror.xheldon.com/docs/ref/#model.Fragment" target="_blank" rel="noopener noreferrer">fragment</a>对象，而每个<code>fragment</code>又包含 0 个或多个字节点，组成了<code>document</code>解构，类似于<code>DOM</code>树</p><p>.<img src="/blog/_assets/doc-node.74422614.jpg" alt="doc-node.jpg"></p><h3 id="schema"><a class="header-anchor" href="#schema" aria-hidden="true">#</a> <a href="https://prosemirror.net/docs/guide/#schema" target="_blank" rel="noopener noreferrer">Schema</a></h3><p>用于定义文档的结构和内容。它定义了一组节点类型和它们的属性，例如段落、标题、链接、图片等等。<code>Schema</code> 是编辑器的模型层，可以通过其 <code>API</code> 创建、操作和验证文档中的节点。每个<code>document</code>都有一个与之相关的<code>schema</code>，用于描述存在于此<code>document</code>中的<code>nodes</code>类型</p><h3 id="node"><a class="header-anchor" href="#node" aria-hidden="true">#</a> <a href="https://prosemirror.net/docs/ref/#model.Node" target="_blank" rel="noopener noreferrer">Node</a></h3><p>文档中的节点，节点是 <code>Schema</code> 中定义的类型之一，整个文档就是一个<code>Node</code>实例，它的每个子节点，例如一个段落、一个列表项、一张图片也是<code>Node</code>的实例。<code>Node</code>的修改遵循<code>Immutable</code>原则，更新时创建一个新的节点，而不是改变旧的节点，统一使用<a href="https://prosemirror.net/docs/ref/#view.EditorView.dispatch" target="_blank" rel="noopener noreferrer">dispatch</a>去触发更新。</p><div class="language-js"><pre><code><span class="token keyword">const</span> node <span class="token operator">=</span> $cell<span class="token punctuation">.</span><span class="token function">node</span><span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span>\n<span class="token comment">// 当前节点类型</span>\nnode<span class="token punctuation">.</span>type\n<span class="token comment">// 节点的attributes</span>\nnode<span class="token punctuation">.</span>attrs\n<span class="token comment">// 从指定node中获取符合条件的子节点</span>\n<span class="token function">findChildren</span><span class="token punctuation">(</span>tr<span class="token punctuation">.</span>doc<span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token parameter">node</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> node<span class="token punctuation">.</span>type<span class="token punctuation">.</span>name <span class="token operator">===</span> <span class="token string">&#39;table&#39;</span><span class="token punctuation">)</span>\n</code></pre></div><h3 id="mark"><a class="header-anchor" href="#mark" aria-hidden="true">#</a> <a href="https://prosemirror.net/docs/ref/#model.Mark" target="_blank" rel="noopener noreferrer">Mark</a></h3><p>用于给节点添加样式、属性或其他信息的一种方式。<code>Prosemirror</code> 将行内文本视作扁平结构而非 DOM 类似的树状结构，这样是为了方便计数和操作。例如，一个文本节点可以添加加粗、斜体、下划线等样式，也可以添加标签、链接等属性。<code>Mark</code> 本身没有节点结构，只是对一个节点的文本内容进行修饰。<code>Marks</code>通过<code>Schema</code>创建，用于控制哪些<code>marks</code>存在于哪些节点以及用于哪些<code>attributes</code>。</p><h3 id="state"><a class="header-anchor" href="#state" aria-hidden="true">#</a> <a href="https://prosemirror.net/docs/guide/#state" target="_blank" rel="noopener noreferrer">State</a></h3><p><code>Prosemirror</code> 的数据结构对象，相当于是 <code>react</code> 的 <code>state</code>，有 <code>view</code> 的 <code>state</code> 和 <code>plugin</code> 的局部 <code>state</code> 之分。 如上面的 <code>schema</code> 就定义在其上： <code>state.schema</code>。<code>ProseMirror</code> 使用一个单独的大对象来保持对编辑器所有 <code>state</code> 的引用（基本上来说，需要创建一个与当前编辑器相同的编辑器）</p><p><img src="/blog/_assets/prosemirror-state.b07f2115.jpg" alt="prosemirror-state"></p><h3 id="transaction"><a class="header-anchor" href="#transaction" aria-hidden="true">#</a> <a href="https://prosemirror.net/docs/guide/" target="_blank" rel="noopener noreferrer">Transaction</a></h3><p>继承自<a href="https://prosemirror.net/docs/guide/#transform" target="_blank" rel="noopener noreferrer">Transform</a>，不仅能追踪对文档进行修改的一组操作，还能追踪<code>state</code>的其他变化，例如选区更新等。每次更新都会产生一个新的<code>state.transactions</code>（通过<code>state.tr</code>来创建一个<code>transaction</code>实例），描述当前<code>state</code>被应用的变化，这些变化用来应用当前<code>state</code>来创建一个更新之后的<code>state</code>，然后这个新的<code>state</code>被用来更新<code>view</code>。</p><blockquote><p>此处的<code>state</code>指的是<code>EditorState</code>，描述编辑器的状态，包含了文档的内容、选区、当前的节点和标记集合等信息。每次编辑器发生改变时，都会生成一个新的 <code>EditorState</code>。</p></blockquote><h3 id="view"><a class="header-anchor" href="#view" aria-hidden="true">#</a> <a href="https://prosemirror.net/docs/guide/#view" target="_blank" rel="noopener noreferrer">View</a></h3><p><code>ProseMirror</code>编辑器的视图层，负责渲染文档内容和处理用户的输入事件。<code>View</code> 接受来自 <code>EditorState</code> 的更新并将其渲染到屏幕上。同时，它也负责处理来自用户的输入事件，如键盘输入、鼠标点击等。其中<code>state</code>就是其上的一个属性：<code>view.state</code></p><p>新建编辑器第一步就是<code>new</code>一个<code>EditorVIew</code></p><h3 id="plugin"><a class="header-anchor" href="#plugin" aria-hidden="true">#</a> <a href="https://prosemirror.net/docs/ref/#state.Plugin_System" target="_blank" rel="noopener noreferrer">Plugin</a></h3><p><code>ProseMirror</code> 中的插件，用于扩展编辑器的功能，例如点击/粘贴/撤销等。每个插件都是一个包含了一组方法的对象，这些方法可以监听编辑器的事件、修改事务、渲染视图等等。每个插件都包含一个<code>key</code>属性，如<code>prosemirror-tables</code>设置<code>key</code>为<code>tableColumnResizing</code>，通过这个<code>key</code>就可以访问插件的配置和状态，而无需访问插件实例对象。</p><div class="language-js"><pre><code><span class="token keyword">const</span> pluginState <span class="token operator">=</span> columnResizingPluginKey<span class="token punctuation">.</span><span class="token function">getState</span><span class="token punctuation">(</span>state<span class="token punctuation">)</span>\n</code></pre></div><h3 id="commands"><a class="header-anchor" href="#commands" aria-hidden="true">#</a> <a href="https://prosemirror.net/docs/guide/#commands" target="_blank" rel="noopener noreferrer">Commands</a></h3><p>表示<code>Command</code>函数集合，每个<code>command</code>函数定义一些触发事件来执行各种操作。</p><h3 id="decorations"><a class="header-anchor" href="#decorations" aria-hidden="true">#</a> <a href="https://www.xheldon.com/tech/prosemirror-guide-chinese.html?mode=light#decorations" target="_blank" rel="noopener noreferrer">Decorations</a></h3><p>表示节点的外观和行为的对象。它可以用于添加样式、标记、工具提示等效果，以及处理点击、悬停、拖拽等事件。<code>Decoration</code> 通常是在渲染视图时应用到节点上的，但也可以在其他情况下使用，如在协同编辑时标记其他用户的光标位置。</p><p>用于绘制<code>document view</code>，通过<code>decorations</code>属性的返回值来创建，包含三种类型</p><ul><li>Node decorations：增加样式或其他 <code>DOM</code> 属性到单个<code>node</code> 的 <code>DOM</code> 上，如选中表格时增加的类名</li><li>Widget decorations：在给定位置插入 <code>DOM node</code>，并不是实际文档的一部分，如表格拖拽时增加的基线</li><li>Inline decoration：在给定的 <code>range</code> 中的行内杨素插入样式或属性，类似于 <code>Node decorations</code>，仅针对行内元素</li></ul><p><code>prosemirror</code> 为了快速绘制这些类型，通过 <code>decorationSet.create</code> 静态方法来创建</p><div class="language-js"><pre><code><span class="token keyword">import</span> <span class="token punctuation">{</span> Plugin<span class="token punctuation">,</span> PluginKey <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">&#39;prosemirror-state&#39;</span>\n<span class="token keyword">let</span> purplePlugin <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Plugin</span><span class="token punctuation">(</span><span class="token punctuation">{</span>\n  <span class="token literal-property property">props</span><span class="token operator">:</span> <span class="token punctuation">{</span>\n    <span class="token function">decorations</span><span class="token punctuation">(</span><span class="token parameter">state</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n      <span class="token keyword">return</span> DecorationSet<span class="token punctuation">.</span><span class="token function">create</span><span class="token punctuation">(</span>state<span class="token punctuation">.</span>doc<span class="token punctuation">,</span> <span class="token punctuation">[</span>\n        Decoration<span class="token punctuation">.</span><span class="token function">inline</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> state<span class="token punctuation">.</span>doc<span class="token punctuation">.</span>content<span class="token punctuation">.</span>size<span class="token punctuation">,</span> <span class="token punctuation">{</span>\n          <span class="token literal-property property">style</span><span class="token operator">:</span> <span class="token string">&#39;color: purple&#39;</span><span class="token punctuation">,</span>\n        <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">,</span>\n      <span class="token punctuation">]</span><span class="token punctuation">)</span>\n    <span class="token punctuation">}</span><span class="token punctuation">,</span>\n  <span class="token punctuation">}</span><span class="token punctuation">,</span>\n<span class="token punctuation">}</span><span class="token punctuation">)</span>\n</code></pre></div><h3 id="resolvedpos"><a class="header-anchor" href="#resolvedpos" aria-hidden="true">#</a> <a href="https://prosemirror.net/docs/ref/#model.Resolved_Positions" target="_blank" rel="noopener noreferrer">ResolvedPos</a></h3><p><code>Prosemirror</code>中通过<code>Node.resolve</code>解析位置信息返回的对象，包含了一些位置相关的信息。它会告诉我们当前<code>position</code>的父级<code>node</code>是什么，它在父级<code>node</code>中的偏移量（<code>parentOffset</code>）是多少以及其他信息。</p><div class="language-js"><pre><code><span class="token keyword">const</span> $cell <span class="token operator">=</span> doc<span class="token punctuation">.</span><span class="token function">resolve</span><span class="token punctuation">(</span>cell<span class="token punctuation">)</span>\n<span class="token comment">// 从根节点开始，父级点的深度，如果直接指向根节点则为0，如果指定一个顶级节点，则为1</span>\n$cell<span class="token punctuation">.</span>deth\n<span class="token comment">// 该位置相对于父节点的偏移量</span>\n$cell<span class="token punctuation">.</span>parentOffset\n<span class="token comment">// 相当于$cell.parent() 获取父级节点，$cell.node(-2)获取父级的父级，以此类推</span>\n$cell<span class="token punctuation">.</span><span class="token function">node</span><span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span>\n<span class="token comment">// 获取父节点的开始位置，相对于doc根节点的位置，一般用来定位</span>\n$cell<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span>\n</code></pre></div><h3 id="selection"><a class="header-anchor" href="#selection" aria-hidden="true">#</a> <a href="https://prosemirror.net/docs/ref/#state.Selection" target="_blank" rel="noopener noreferrer">Selection</a></h3><p>表示当前选中内容，<code>prosemirror</code>中默认定义两种类型的选区对象：</p><ul><li>TextSelection：文本选区，同时也可以表示正常的光标（即未选择任何文本时，此时<code>anchor = head</code>），包含<code>$anchor</code>选区固定的一侧，通常是左侧，<code>$head</code>选区移动的一侧，通常是右侧</li><li>NodeSelection：节点选区，表示一个节点被选择</li></ul><p>也可以通过继承<code>Selection</code>父类来实现自定义的选区类型，如<code>CellSelection</code></p><div class="language-js"><pre><code><span class="token comment">// 获取当前选区</span>\n<span class="token keyword">const</span> sel <span class="token operator">=</span> state<span class="token punctuation">.</span>selection\n<span class="token comment">// 使用TextSelection创建文本选区</span>\n<span class="token keyword">const</span> selection <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">TextSelection</span><span class="token punctuation">(</span>$textAnchor<span class="token punctuation">,</span> $textHead<span class="token punctuation">)</span>\n<span class="token comment">// 使用NodeSelection创建节点选区</span>\n<span class="token keyword">const</span> selection <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">NodeSelection</span><span class="token punctuation">(</span>$pos<span class="token punctuation">)</span>\n<span class="token comment">// 使用AllSelection创建覆盖整个文档的选区 可以作为cmd + a的操作</span>\n<span class="token keyword">const</span> selection <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">AllSelection</span><span class="token punctuation">(</span>doc<span class="token punctuation">)</span>\n<span class="token comment">// 用new之后的选区，更新当前 transaction 的选区</span>\nstate<span class="token punctuation">.</span>tr<span class="token punctuation">.</span><span class="token function">setSelection</span><span class="token punctuation">(</span>selection<span class="token punctuation">)</span>\n<span class="token comment">// 从指定选区获取符合条件的父节点</span>\n<span class="token function">findParentNode</span><span class="token punctuation">(</span>\n  <span class="token punctuation">(</span><span class="token parameter">node</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span>\n    node<span class="token punctuation">.</span>type<span class="token punctuation">.</span>spec<span class="token punctuation">.</span>tableRole <span class="token operator">&amp;&amp;</span> node<span class="token punctuation">.</span>type<span class="token punctuation">.</span>spec<span class="token punctuation">.</span>tableRole<span class="token punctuation">.</span><span class="token function">includes</span><span class="token punctuation">(</span><span class="token string">&#39;cell&#39;</span><span class="token punctuation">)</span>\n<span class="token punctuation">)</span><span class="token punctuation">(</span>selection<span class="token punctuation">)</span>\n</code></pre></div><h3 id="slice"><a class="header-anchor" href="#slice" aria-hidden="true">#</a> <a href="https://prosemirror.net/docs/guide/#intro" target="_blank" rel="noopener noreferrer">Slice</a></h3><ul><li><code>slice of document</code>称为<code>文档片段</code>，主要处理复制粘贴和拖拽之类的操作</li><li>两个<code>position</code>之间的内容就是一个<code>文档片段</code></li></ul><h2 id="源码目录"><a class="header-anchor" href="#源码目录" aria-hidden="true">#</a> 源码目录</h2><div class="language-bash"><pre><code>├── README.md\n├── cellselection.ts\n├── columnresizing.ts\n├── commands.ts\n├── copypaste.ts\n├── fixtables.ts\n├── index.html\n├── index.ts\n├── input.ts\n├── schema.ts\n├── tablemap.ts\n├── tableview.ts\n└── util.ts\n</code></pre></div><h3 id="cellselection-ts"><a class="header-anchor" href="#cellselection-ts" aria-hidden="true">#</a> cellselection.ts</h3><p>定义<code>CellSelection</code>选区对象，继承自<code>Selection</code></p><ul><li>drawCellSelection：用于当跨单元格选择时，绘制选区，会添加到<code>tableEditing</code>的<code>decorations</code>为每个选中节点增加<code>class</code>类<code>selectedCell</code> ，<code>tableEditing</code>最后会注册为<code>Editor</code>的插件使用</li></ul><h3 id="columnresizing-ts"><a class="header-anchor" href="#columnresizing-ts" aria-hidden="true">#</a> columnresizing.ts</h3><p>定义<code>columnResizing</code>插件，用于实现列拖拽功能，大致思路如下：</p><ul><li><p>插件初始化时，通过以下代为插件添加<code>nodeViews</code>，通过实例化<code>TableView</code>为表格节点自定义一套渲染逻辑，在初始化的时候为<code>DOM</code>节点添加了<code>colgroup</code>，然后调用<code>updateColumnWidth</code>生成每列对应的<a href="https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/col" target="_blank" rel="noopener noreferrer">col</a>，有了<code>col</code>之后，我们在调整列宽的时候就可以通过改变<code>col</code>的<code>width</code>属性实时的去改变列宽了。</p><div class="language-ts"><pre><code>plugin<span class="token punctuation">.</span>spec<span class="token operator">!</span><span class="token punctuation">.</span>props<span class="token operator">!</span><span class="token punctuation">.</span>nodeViews<span class="token operator">!</span><span class="token punctuation">[</span><span class="token function">tableNodeTypes</span><span class="token punctuation">(</span>state<span class="token punctuation">.</span>schema<span class="token punctuation">)</span><span class="token punctuation">.</span>table<span class="token punctuation">.</span>name<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">(</span>\n  node<span class="token punctuation">,</span>\n  view\n<span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token keyword">new</span> <span class="token class-name">View</span><span class="token punctuation">(</span>node<span class="token punctuation">,</span> cellMinWidth<span class="token punctuation">,</span> view<span class="token punctuation">)</span>\n</code></pre></div></li><li><p>通过设置插件的<code>props</code>传入<code>attribute</code>（控制何时添加类<code>resize-cursor</code>）、<code>handleDOMEvents</code>（定义<code>mousemove</code>、<code>mouseleave</code>和<code>mousedown</code>事件）和<code>decorations</code>（调用<code>handleDecorations</code>方法，在鼠标移动到列上时，通过<code>Decoration.widget</code>来绘制所需要的<code>DOM</code>）</p><ul><li>doc.resolve(cell)： <code>resolve</code>解析文档中给定的位置，返回此位置的上下文信息</li><li>$cell.node(-1)： 获取给定级别的祖先节点</li><li>$cell.start(-1)： 获取给定级别节点到起点的（绝对）位置</li><li>TableMap.get(table)： 获取当前表格数据，包含 <code>width</code> 列数、<code>height</code> 行数、<code>map</code> 行 <code>pos</code> 列 <code>pos</code> 形成的数组</li><li>循环 <code>map.height</code>，为当前列的每一个<code>td</code>上创建一个<code>div</code></li></ul></li><li><p><code>handleMouseMove</code>当鼠标移动时，修改<code>pluginState</code>从而使得<code>decorations</code>重新绘制<code>DOM</code></p></li><li><p><code>handleMouseDown</code>当鼠标按下时，获取当前位置信息和列宽，并记录在<code>pluginState</code></p><p>此方法中重新定义<code>mouseup</code>和<code>mousemove</code>事件</p><ul><li><p>move：移动的同时从<code>draggedWidth</code>获取移动宽度，调用<code>updateColumnsOnResize</code>实时更新<code>colgroup</code>中的<code>col</code>的<code>width</code>属性，从而改变每列宽度</p></li><li><p>finish：当移动完成后调用<code>updateColumnWidth</code>方法重置当前列的<code>attrs</code>属性，并将<code>pluginState</code>置为初始状态</p><div class="language-js"><pre><code><span class="token comment">// 用来改变给定 position node 的类型或者属性</span>\ntr<span class="token punctuation">.</span><span class="token function">setNodeMarkup</span><span class="token punctuation">(</span>start <span class="token operator">+</span> pos<span class="token punctuation">,</span> <span class="token keyword">null</span><span class="token punctuation">,</span> <span class="token punctuation">{</span> <span class="token operator">...</span>attrs<span class="token punctuation">,</span> <span class="token literal-property property">colwidth</span><span class="token operator">:</span> colwidth <span class="token punctuation">}</span><span class="token punctuation">)</span>\n</code></pre></div></li></ul></li><li><p><code>handleMouseLeave</code>当鼠标离开时，恢复<code>pluginState</code>为初始状态，完成列拖拽</p></li></ul><h3 id="commands-ts"><a class="header-anchor" href="#commands-ts" aria-hidden="true">#</a> commands.ts</h3><p>定义操作表格的一系列方法</p><ul><li><p>selectedRect：获取表格中的选区，并返回选区信息、表格起始偏移量、表格信息（<code>TableMap.get(table)</code>的值）和当前表格，这个方法很有用，能拿到当前表格中的所有信息</p><p><img src="/blog/_assets/table-info.5fb7cf28.jpg" alt="table-info.jpg"></p></li><li><p>剩下的方法都是需要用到的功能函数，像<code>addColumn</code>、<code>addRow</code>等</p></li></ul><h3 id="copypaste-ts"><a class="header-anchor" href="#copypaste-ts" aria-hidden="true">#</a> copypaste.ts</h3><p>用于处理将单元格内容粘贴到表格中、或将任何内容粘贴到单元格选择中，如用选择内容替换单元格块。</p><p>当在单元格中<code>cmd + v</code>触发粘贴时，步骤为：</p><ol><li><p>调用<code>input.ts</code>中的<code>handlePaste</code>方法，根据传入的<code>文档片段</code>去做相应处理</p></li><li><p>调用<code>pastedCells</code>，从<code>文档片段</code>中获取单元格的矩形区域，如果<code>文档片段</code>的外部节点不是表格单元格或行，则返回<code>null</code>，如果是的话会根据当前<code>slice</code>传入<code>ensureRectangular</code>去生成新的一组单元格</p><div class="language-js"><pre><code><span class="token comment">// 判断是否为单元格或行，主要通过schema中定义的tableRole来判断</span>\n<span class="token comment">// 行</span>\nfirst<span class="token punctuation">.</span>type<span class="token punctuation">.</span>spec<span class="token punctuation">.</span>tableRole <span class="token operator">===</span> <span class="token string">&#39;row&#39;</span>\n<span class="token comment">// 单元格</span>\nfirst<span class="token punctuation">.</span>type<span class="token punctuation">.</span>spec<span class="token punctuation">.</span>tableRole <span class="token operator">===</span> <span class="token string">&#39;cell&#39;</span>\nfirst<span class="token punctuation">.</span>type<span class="token punctuation">.</span>spec<span class="token punctuation">.</span>tableRole <span class="token operator">===</span> <span class="token string">&#39;header_cell&#39;</span>\n</code></pre></div></li><li><p>判断当前选区是否为<code>CellSelection</code>，即是否选中一个或多个单元格的情况，会调用<code>clipCells</code>方法根据生成的<code>cells</code>生成表格新的一组单元格，通过<code>insertCells</code>插入原表格指定位置</p><ul><li>insertCells：将给定的一组单元格（由 <code>pastedCells</code> 返回）插入表格中 <code>rect</code> 指向的位置</li><li>growTable、<code>isolateHorizontal</code>和<code>isolateVertical</code>主要是为了确保被插入的表格足够大，足够容得下插入的单元格</li></ul></li><li><p>如果当前选区不是<code>CellSelection</code>，但是<code>pastedCells</code>生成了新的<code>cells</code>，即复制的是表格单元格，则同样使用<code>insertCells</code>插入</p></li><li><p>不满足上面两个条件时，返回<code>false</code>，即不用处理，按浏览器默认行为处理</p></li></ol><h3 id="fixtables-ts"><a class="header-anchor" href="#fixtables-ts" aria-hidden="true">#</a> fixtables.ts</h3><p>定义了<code>tiptap</code>中的<code>fixTables</code>命令，用于检查文档中的所有表格并在必要时修复。通过代码可以看到<code>fixTables</code>就是遍历<code>state.doc</code>的所有子节点，如果是<code>table</code>的话就调用<code>fixTable</code>。而<code>fixTable</code>修复表格主要是根据表格是否存在<code>TableMap.get(table).problems</code>来做处理，<code>problems</code>包含四种类型</p><ul><li>collision：直译为“碰撞”，我理解就是单元格相互挤压，处理方式是通过<code>removeColSpan</code>处理掉对应的单元格</li><li>missing：直译为”丢失“，处理方式是为丢失的单元格添加必要的单元格</li><li>overlong_rowspan：直译为“过长的 rowspan”，处理方式是修改对应单元格的<code>rowspan</code></li><li>colwidth-mismatch：直译为“宽度不匹配”，处理方式是修改对应单元格的<code>colwidth</code></li></ul><p>因为目前我没遇到过这些错误，所以对这些名词的理解还不是很清晰。</p><h3 id="index-ts"><a class="header-anchor" href="#index-ts" aria-hidden="true">#</a> index.ts</h3><p>定义插件<code>tableEditing</code>，用于处理单元格选择的绘制、以及创建和使用此类选择的基本用户交互。这个插件需要放在所有插件数组的末尾，因为它处理表格中的鼠标事件相当广泛。而其他插件，比如列宽拖动<code>columnResizing</code>插件，需要首先执行更具体的行为。 插件的<code>props</code>上定义了以下事件处理函数，这些事件处理函数如果返回<code>true</code>，说明它们处理了相应的事件，如果返回<code>false</code>则还是触发浏览器对应的事件</p><ul><li>handleDOMEvents：优先级最高，会先于其他处理任何发生在可编辑<code>DOM</code>元素上的事件之前调用，这里注册了<code>mousedown</code>函数，调用<code>input.js</code>中的<code>handleMouseDown</code>事件，处理鼠标按下事件</li><li>handleTripleClick：三次单击编辑器时调用，这里会调用<code>handleTripleClick</code>函数，当三次单击的时候选中当前单元格</li><li>handleKeyDown：当编辑器收到 <code>keydown</code> 事件时调用，这里会调用<code>handleKeyDown</code>函数，绑定一些操作表格的快捷键</li><li>handlePaste：用于覆盖粘贴行为，<code>slice</code>是编辑器解析出来的粘贴内容，这里会调用<code>handlePaste</code>函数，<a href="./上面.html">上面</a>已经说过，就不再重复</li></ul><h3 id="input-ts"><a class="header-anchor" href="#input-ts" aria-hidden="true">#</a> input.ts</h3><p>定义了一些功能函数，用于链接用户输入与<code>table</code>相关功能</p><h3 id="schema-ts"><a class="header-anchor" href="#schema-ts" aria-hidden="true">#</a> schema.ts</h3><ul><li>定义<code>tables</code>的<code>node types</code>，分别为<code>table</code>、<code>table_header</code>、<code>table_cell</code>和<code>table_row</code>节点</li><li><code>tableNodeTypes(schema)</code>函数接受<code>schema</code>，返回上述定义的<code>node types</code>，可以用来判断传入的<code>schema</code>是否为<code>table</code>节点</li></ul><h3 id="tablemap-ts"><a class="header-anchor" href="#tablemap-ts" aria-hidden="true">#</a> tablemap.ts</h3><p>定义 TableMap 类，可以参考<a href="https://github.com/ProseMirror/prosemirror-tables#class-tablemap" target="_blank" rel="noopener noreferrer">prosemirror-tables</a>关于<code>class TableMap</code>的说明，或<a href="https://github.com/wang1xiang/prosemirror-tables/blob/readme-zh/README-zh.md#class-tablemap" target="_blank" rel="noopener noreferrer">中文翻译</a>。这里为了性能考虑，做了缓存处理。如果缓存中不存在对应表格的<code>tableMap</code>时，会通过<code>computeMap</code>重新获取<code>tableMap</code>，并放入缓存中。</p><h3 id="tableview-ts"><a class="header-anchor" href="#tableview-ts" aria-hidden="true">#</a> tableview.ts</h3><p><a href="https://prosemirror.net/docs/ref/#view.NodeView" target="_blank" rel="noopener noreferrer">参考</a></p><ul><li>此处定义的<code>TableView</code>继承自<a href="https://prosemirror.net/docs/ref/#view.NodeView" target="_blank" rel="noopener noreferrer">NodeView</a>，一般来说自定义<code>nodeView</code>都是为了更细粒度的控制节点在编辑器中的表现样式，如此处用于控制表格列拖拽时的样式和行为</li><li><a href="./.html">上面</a>已经提到了，会提供给插件<code>columnresizing</code>的<code>NodeViews</code>使用，所以要是不用实现列拖拽功能时，这个文件也就没什么用了</li></ul><h3 id="util-ts"><a class="header-anchor" href="#util-ts" aria-hidden="true">#</a> util.ts</h3><p>定义一些用于处理表格的各种辅助函数</p><p>cellAround：根据传入的位置返回当前单元格的位置信息</p><p>cellWrapping：根据传入的位置返回当前单元</p><p>isInTable：传入 state`判断当前选区是否在表格中</p><p>selectionCell：传入<code>state</code>返回当前选区的位置信息</p><p>pointsAtCell：根据传入的位置判断是否在单元格内，返回<code>true</code>或<code>false</code></p><p>moveCellForward：获取当前单元格的前一个单元格位置信息</p><p>inSameTable：判断当前选区是否属于同一个表格</p><p>findCell：找到给定位置的单元格的尺寸</p><p>colCount：调用<code>TableMap</code>的<code>colCount</code>方法，返回当前单元格的列数</p><p>nextCell：根据传入的位置，在给定方向上查找下一个单元格</p><p>removeColSpan：为指定单元格删除<code>colspan</code></p><p>addColSpan：为指定单元格添加<code>colspan</code>，根据传入的<code>n</code>来设定</p><p>columnIsHeader：判断当前单元格是否为<code>header</code></p>',92)];s.render=function(n,a,s,c,p,l){return e(),o("div",null,t)};export{a as __pageData,s as default};
