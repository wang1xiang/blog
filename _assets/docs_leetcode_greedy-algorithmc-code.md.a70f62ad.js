import{f as n,g as s,J as a}from"./common-03e46d7f.js";const p='{"title":"跟着卡哥学算法Day 27：贪心算法理论 & part1","frontmatter":{"date":"2025-03-10","title":"跟着卡哥学算法Day 27：贪心算法理论 & part1","tags":["leetcode"],"describe":"贪心算法理论 & part1"},"headers":[{"level":2,"title":"贪心算法","slug":"贪心算法"},{"level":3,"title":"核心思想","slug":"核心思想"},{"level":3,"title":"什么时候用贪心","slug":"什么时候用贪心"},{"level":3,"title":"贪心法经典场景","slug":"贪心法经典场景"},{"level":3,"title":"贪心法解题步骤","slug":"贪心法解题步骤"},{"level":2,"title":"455.分发饼干 🌟","slug":"_455-分发饼干-🌟"},{"level":3,"title":"题目描述","slug":"题目描述"},{"level":3,"title":"解题思路","slug":"解题思路"},{"level":3,"title":"代码","slug":"代码"},{"level":2,"title":"376. 摆动序列 🌟🌟","slug":"_376-摆动序列-🌟🌟"},{"level":3,"title":"题目描述","slug":"题目描述-2"},{"level":3,"title":"解题思路","slug":"解题思路-2"},{"level":3,"title":"代码","slug":"代码-2"},{"level":2,"title":"53. 最大子序和 🌟🌟","slug":"_53-最大子序和-🌟🌟"},{"level":3,"title":"题目描述","slug":"题目描述-3"},{"level":3,"title":"解题思路","slug":"解题思路-3"}],"relativePath":"docs/leetcode/greedy-algorithmc-code.md","lastUpdated":1743653323544.1055}';var t={};const o=[a('<h2 id="贪心算法"><a class="header-anchor" href="#贪心算法" aria-hidden="true">#</a> 贪心算法</h2><p><strong>贪心的本质是选择每一阶段的局部最优，从而达到全局最优</strong>。</p><h3 id="核心思想"><a class="header-anchor" href="#核心思想" aria-hidden="true">#</a> 核心思想</h3><ul><li><strong>局部最优选择</strong>：每一步只考虑当前最优解，不关系后序步骤的影响</li><li><strong>不可逆性</strong>：没有类似回溯的步骤</li></ul><p>举例：有一堆钞票，只能拿 10 张，如果想要达到最大金额，应该怎么拿？</p><p>指定每次拿最大的，最终结果就是拿走最大数额的钱。</p><h3 id="什么时候用贪心"><a class="header-anchor" href="#什么时候用贪心" aria-hidden="true">#</a> 什么时候用贪心</h3><p>没有固定套路</p><p>贪心法适用于满足以下两个条件的问题：</p><ul><li><strong>贪心选择性质（Greedy Choice Property）</strong>：通过每一步的局部最优选择，最终能构造出全局最优解</li><li><strong>最优子结构（Optimal Substructure）</strong>：问题的最优解包含其子问题的最优解</li></ul><h3 id="贪心法经典场景"><a class="header-anchor" href="#贪心法经典场景" aria-hidden="true">#</a> 贪心法经典场景</h3><ol><li><p>活动选择问题</p><ul><li>问题：从多个时间不重叠的活动中选出最多的活动</li><li>贪心策略：每次选择结束时间最早的活动，为后续留出更多时间</li></ul></li><li><p>霍夫曼编码（Huffman Coding）</p><ul><li>问题：用最短的二进制编码表示字符，实现数据压缩</li><li>贪心策略：优先合并频率最低的两个节点，生成最优前缀码</li></ul></li><li><p>最小生成树（Prim/Kruskal 算法）</p><ul><li>问题：在带权图中找连接所有顶点的最小权值和的树</li><li>贪心策略 <ul><li>Prim：每次选当前已选顶点到未选顶点的最小边</li><li>Kruskal：每次选全图未选的最小边，且不形成环</li></ul></li></ul></li><li><p>最短路径问题（Dijkstra 算法）</p><ul><li>问题：在带权图中找单源最短路径</li><li>贪心策略：每次从未处理的顶点中选择距离起点最近的顶点，更新其邻居的最短路径</li></ul></li><li><p>零钱兑换问题（部分场景）</p><ul><li>问题：用最少的硬币数凑出某个金额</li><li>贪心策略：优先使用面值最大的硬币（需满足硬币面值满足贪心条件，如美元中的 1, 5, 10, 25 分）</li></ul></li></ol><h3 id="贪心法解题步骤"><a class="header-anchor" href="#贪心法解题步骤" aria-hidden="true">#</a> 贪心法解题步骤</h3><p>一般分为如下四步：</p><ol><li>将问题分解为若干个子问题</li><li>找出适合的贪心策略</li><li>求解每一个子问题的最优解</li><li>将局部最优解堆叠成全局最优解</li></ol><h2 id="_455-分发饼干-🌟"><a class="header-anchor" href="#_455-分发饼干-🌟" aria-hidden="true">#</a> 455.分发饼干 🌟</h2><p><a href="https://leetcode.cn/problems/assign-cookies/description/" target="_blank" rel="noopener noreferrer">力扣链接</a> 🌟</p><h3 id="题目描述"><a class="header-anchor" href="#题目描述" aria-hidden="true">#</a> 题目描述</h3><p>假设你是一位很棒的家长，想要给你的孩子们一些小饼干。但是，每个孩子最多只能给一块饼干。</p><p>对每个孩子 i，都有一个胃口值 g[i]，这是能让孩子们满足胃口的饼干的最小尺寸；并且每块饼干 j，都有一个尺寸 s[j] 。如果 s[j] &gt;= g[i]，我们可以将这个饼干 j 分配给孩子 i ，这个孩子会得到满足。你的目标是尽可能满足越多数量的孩子，并输出这个最大数值。</p><p>示例 1:</p><ul><li>输入: g = [1,2,3], s = [1,1]</li><li>输出: 1</li><li>解释:你有三个孩子和两块小饼干，3 个孩子的胃口值分别是：1,2,3。虽然你有两块小饼干，由于他们的尺寸都是 1，你只能让胃口值是 1 的孩子满足。所以你应该输出 1。</li></ul><p>示例 2:</p><ul><li>输入: g = [1,2], s = [1,2,3]</li><li>输出: 2</li><li>解释:你有两个孩子和三块小饼干，2 个孩子的胃口值分别是 1,2。你拥有的饼干数量和尺寸都足以让所有孩子满足。所以你应该输出 2.</li></ul><p>提示：</p><ul><li><code>1 &lt;= g.length &lt;= 3 * 10^4</code></li><li><code>0 &lt;= s.length &lt;= 3 * 10^4</code></li><li><code>1 &lt;= g[i], s[j] &lt;= 2^31 - 1</code></li></ul><h3 id="解题思路"><a class="header-anchor" href="#解题思路" aria-hidden="true">#</a> 解题思路</h3><p><strong>局部最优：大饼干尽量满足胃口大的小孩，充分利用饼干尺寸喂饱一个</strong><strong>全局最优：喂饱尽可能多的小孩</strong></p><p>局部最优能满足全局最优，并且找不出反例否决我们的想法</p><ol><li>排序：对胃口数组 g 和饼干数组 s 排序</li><li>双指针遍历：两个数组都从尾部可是递减，如果 g[i] &lt;= s[j]，则满足一个小孩，两个指针前移</li></ol><h3 id="代码"><a class="header-anchor" href="#代码" aria-hidden="true">#</a> 代码</h3><div class="language-js"><pre><code><span class="token keyword">var</span> <span class="token function-variable function">findContentChildren</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">g<span class="token punctuation">,</span> s</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  g<span class="token punctuation">.</span><span class="token function">sort</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">a<span class="token punctuation">,</span> b</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> a <span class="token operator">-</span> b<span class="token punctuation">)</span>\n  s<span class="token punctuation">.</span><span class="token function">sort</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">a<span class="token punctuation">,</span> b</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> a <span class="token operator">-</span> b<span class="token punctuation">)</span>\n\n  <span class="token keyword">let</span> result <span class="token operator">=</span> <span class="token number">0</span>\n  <span class="token keyword">let</span> j <span class="token operator">=</span> s<span class="token punctuation">.</span>length <span class="token operator">-</span> <span class="token number">1</span>\n\n  <span class="token comment">// 遍历胃口  无论是否满足，移动到上一个胃口</span>\n  <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> g<span class="token punctuation">.</span>length <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&gt;=</span> <span class="token number">0</span><span class="token punctuation">;</span> i<span class="token operator">--</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token comment">// 遍历饼干 当前孩子被满足，移动到上一个饼干</span>\n    <span class="token keyword">if</span> <span class="token punctuation">(</span>j <span class="token operator">&gt;=</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> g<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">&lt;=</span> s<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n      result<span class="token operator">++</span>\n      j<span class="token operator">--</span>\n    <span class="token punctuation">}</span>\n  <span class="token punctuation">}</span>\n\n  <span class="token keyword">return</span> result\n<span class="token punctuation">}</span>\n</code></pre></div><h2 id="_376-摆动序列-🌟🌟"><a class="header-anchor" href="#_376-摆动序列-🌟🌟" aria-hidden="true">#</a> 376. 摆动序列 🌟🌟</h2><p><a href="https://leetcode.cn/problems/wiggle-subsequence/description/" target="_blank" rel="noopener noreferrer">力扣链接</a> 🌟🌟</p><h3 id="题目描述-2"><a class="header-anchor" href="#题目描述-2" aria-hidden="true">#</a> 题目描述</h3><p>如果连续数字之间的差严格地在正数和负数之间交替，则数字序列称为摆动序列。第一个差（如果存在的话）可能是正数或负数。少于两个元素的序列也是摆动序列。</p><p>例如， [1,7,4,9,2,5] 是一个摆动序列，因为差值 (6,-3,5,-7,3) 是正负交替出现的。相反, [1,4,7,2,5] 和 [1,7,4,5,5] 不是摆动序列，第一个序列是因为它的前两个差值都是正数，第二个序列是因为它的最后一个差值为零。</p><p>给定一个整数序列，返回作为摆动序列的最长子序列的长度。 通过从原始序列中删除一些（也可以不删除）元素来获得子序列，剩下的元素保持其原始顺序。</p><p>示例 1:</p><ul><li>输入: [1,7,4,9,2,5]</li><li>输出: 6</li><li>解释: 整个序列均为摆动序列。</li></ul><p>示例 2:</p><ul><li>输入: [1,17,5,10,13,15,10,5,16,8]</li><li>输出: 7</li><li>解释: 这个序列包含几个长度为 7 摆动序列，其中一个可为[1,17,10,13,10,16,8]。</li></ul><p>示例 3:</p><ul><li>输入: [1,2,3,4,5,6,7,8,9]</li><li>输出: 2</li></ul><h3 id="解题思路-2"><a class="header-anchor" href="#解题思路-2" aria-hidden="true">#</a> 解题思路</h3><p>难度一下飙升</p><p><strong>局部最优：删除单调坡上节点（非顶点），那么这个坡度就有两个局部峰值</strong><strong>整体最优：整个序列有最多的局部峰值，从而达到最长摆动序列</strong></p><ol><li>初始化处理：直接处理数组长度小于等于 1 的情况</li><li>遍历数组：计算当前差值 currDiff</li><li>符号交替判断：比较 prevDiff 和 currDiff，增加计数并更新 prevDiff</li></ol><p>可分为三种情况</p><ul><li><p>情况一：上下坡中有平坡</p><ul><li>如[1,2,2,2,2,1]</li><li>i 指向第一个 2，currDiff = 0，prevDiff &gt; 0</li><li>i 指向第二个 2，currDiff = 0，prevDiff = 0</li><li>i 指向最后一个 2，currDiff &lt; 0，prevDiff = 0</li><li>可以得到条件如下</li></ul><div class="language-js"><pre><code><span class="token keyword">for</span> <span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> nums<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  <span class="token keyword">const</span> currDiff <span class="token operator">=</span> nums<span class="token punctuation">[</span>i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">-</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span>\n  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>preDiff <span class="token operator">&lt;=</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> currDiff <span class="token operator">&gt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token operator">||</span> <span class="token punctuation">(</span>preDiff <span class="token operator">&gt;=</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> currDiff <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    count<span class="token operator">++</span>\n  <span class="token punctuation">}</span>\n  prevDiff <span class="token operator">=</span> currDiff\n<span class="token punctuation">}</span>\n</code></pre></div></li><li><p>情况二：数组首尾两端</p></li><li><p>情况三：单调坡中有平坡</p><ul><li>如[1,2,2,2,3,4]</li><li>按照情况一 每次遍历都会更新 prevDiff</li><li>到 3 时，此时 prevDiff = 0，currDiff = 1 &gt; 0，满足上述条件，count++，导致误统计</li><li><strong>如何更新 prevDiff？</strong></li><li>每次坡度摆动变化的时候，在更新 prevDiff 即可</li></ul><div class="language-js"><pre><code><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> nums<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  <span class="token keyword">const</span> currDiff <span class="token operator">=</span> nums<span class="token punctuation">[</span>i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">-</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span>\n  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>prevDiff <span class="token operator">&lt;=</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> currDiff <span class="token operator">&gt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token operator">||</span> <span class="token punctuation">(</span>prevDiff <span class="token operator">&gt;=</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> currDiff <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    count<span class="token operator">++</span>\n    prevDiff <span class="token operator">=</span> currDiff\n  <span class="token punctuation">}</span>\n<span class="token punctuation">}</span>\n</code></pre></div></li></ul><h3 id="代码-2"><a class="header-anchor" href="#代码-2" aria-hidden="true">#</a> 代码</h3><div class="language-js"><pre><code><span class="token keyword">var</span> <span class="token function-variable function">wiggleMaxLength</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">nums</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  <span class="token keyword">if</span> <span class="token punctuation">(</span>nums<span class="token punctuation">.</span>length <span class="token operator">&lt;=</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token keyword">return</span> nums<span class="token punctuation">.</span>length\n  <span class="token keyword">let</span> prevDiff <span class="token operator">=</span> <span class="token number">0</span>\n  <span class="token keyword">let</span> count <span class="token operator">=</span> <span class="token number">1</span>\n  <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> nums<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token keyword">const</span> currDiff <span class="token operator">=</span> nums<span class="token punctuation">[</span>i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">-</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span>\n    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>prevDiff <span class="token operator">&gt;=</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> currDiff <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token operator">||</span> <span class="token punctuation">(</span>prevDiff <span class="token operator">&lt;=</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> currDiff <span class="token operator">&gt;</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n      count<span class="token operator">++</span>\n      prevDiff <span class="token operator">=</span> currDiff\n    <span class="token punctuation">}</span>\n  <span class="token punctuation">}</span>\n  <span class="token keyword">return</span> count\n<span class="token punctuation">}</span>\n</code></pre></div><h2 id="_53-最大子序和-🌟🌟"><a class="header-anchor" href="#_53-最大子序和-🌟🌟" aria-hidden="true">#</a> 53. 最大子序和 🌟🌟</h2><p><a href="https://leetcode.cn/problems/maximum-subarray/description/" target="_blank" rel="noopener noreferrer">力扣链接</a> 🌟🌟</p><h3 id="题目描述-3"><a class="header-anchor" href="#题目描述-3" aria-hidden="true">#</a> 题目描述</h3><p>给定一个整数数组 nums ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。</p><p>示例:</p><ul><li>输入: [-2,1,-3,4,-1,2,1,-5,4]</li><li>输出: 6</li><li>解释: 连续子数组 [4,-1,2,1] 的和最大，为 6</li></ul><h3 id="解题思路-3"><a class="header-anchor" href="#解题思路-3" aria-hidden="true">#</a> 解题思路</h3><h4 id="暴力法："><a class="header-anchor" href="#暴力法：" aria-hidden="true">#</a> 暴力法：</h4><ul><li>两层 for 循环</li><li>外层 for 循环控制起始位置</li><li>内层 for 循环遍历子数组，计算和，并更新最大和</li></ul><div class="language-js"><pre><code><span class="token keyword">var</span> <span class="token function-variable function">maxSubArray</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">nums</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  <span class="token keyword">let</span> maxSum <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">Infinity</span>\n  <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> nums<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token keyword">let</span> sum <span class="token operator">=</span> <span class="token number">0</span>\n    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> j <span class="token operator">=</span> i<span class="token punctuation">;</span> j <span class="token operator">&lt;</span> nums<span class="token punctuation">.</span>length<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n      sum <span class="token operator">+=</span> nums<span class="token punctuation">[</span>j<span class="token punctuation">]</span>\n      maxSum <span class="token operator">=</span> Math<span class="token punctuation">.</span><span class="token function">max</span><span class="token punctuation">(</span>maxSum<span class="token punctuation">,</span> sum<span class="token punctuation">)</span>\n    <span class="token punctuation">}</span>\n  <span class="token punctuation">}</span>\n  <span class="token keyword">return</span> maxSum\n<span class="token punctuation">}</span>\n</code></pre></div><p>暴力法时间复杂度为 O(n^2)，在 leetcode 中会超时</p><h4 id="贪心法"><a class="header-anchor" href="#贪心法" aria-hidden="true">#</a> 贪心法</h4><p><strong>局部最优：当前连续和为负数，则丢弃，从下一个元素开始重新计算，因为负数加上下一个元素，连续和会越来越小</strong><strong>全局最优：最大连续子数组和</strong></p><p>以[-2,1,-3,4,-1,2,1,-5,4]为例：</p><ul><li>遍历 nums，[-2,1,-3]相加连续和为负数，此时就需要从 4 开始重新计算</li></ul><div class="language-js"><pre><code><span class="token keyword">var</span> <span class="token function-variable function">maxSubArray</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">nums</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  <span class="token keyword">let</span> maxSum <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">Infinity</span>\n  <span class="token keyword">let</span> currentSum <span class="token operator">=</span> <span class="token number">0</span>\n  <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> nums<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    currentSum <span class="token operator">+=</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span>\n\n    maxSum <span class="token operator">=</span> Math<span class="token punctuation">.</span><span class="token function">max</span><span class="token punctuation">(</span>maxSum<span class="token punctuation">,</span> currentSum<span class="token punctuation">)</span>\n    <span class="token keyword">if</span> <span class="token punctuation">(</span>currentSum <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span> currentSum <span class="token operator">=</span> <span class="token number">0</span>\n  <span class="token punctuation">}</span>\n  <span class="token keyword">return</span> maxSum\n<span class="token punctuation">}</span>\n</code></pre></div>',68)];t.render=function(a,p,t,e,l,c){return n(),s("div",null,o)};export{p as __pageData,t as default};
