import{f as n,g as s,J as a}from"./common-03e46d7f.js";const t='{"title":"跟着卡哥学算法Day 14：二叉树常见题目2","frontmatter":{"date":"2025-02-25","title":"跟着卡哥学算法Day 14：二叉树常见题目2","tags":["leetcode"],"describe":"二叉树常见题目2"},"headers":[{"level":2,"title":"226.翻转二叉树 🌟","slug":"_226-翻转二叉树-🌟"},{"level":3,"title":"题目描述","slug":"题目描述"},{"level":3,"title":"解题思路","slug":"解题思路"},{"level":2,"title":"101. 对称二叉树 🌟","slug":"_101-对称二叉树-🌟"},{"level":3,"title":"题目描述","slug":"题目描述-2"},{"level":3,"title":"解题思路","slug":"解题思路-2"},{"level":3,"title":"代码","slug":"代码"},{"level":2,"title":"二叉树的最大深度","slug":"二叉树的最大深度"},{"level":3,"title":"题目描述","slug":"题目描述-3"},{"level":3,"title":"解题思路","slug":"解题思路-3"},{"level":3,"title":"代码","slug":"代码-2"},{"level":2,"title":"二叉树的最小深度","slug":"二叉树的最小深度"},{"level":3,"title":"题目描述","slug":"题目描述-4"},{"level":3,"title":"解题思路","slug":"解题思路-4"},{"level":3,"title":"代码","slug":"代码-3"}],"relativePath":"docs/leetcode/binary-tree-code1.md","lastUpdated":1742205571282.0386}';var p={};const o=[a('<h2 id="_226-翻转二叉树-🌟"><a class="header-anchor" href="#_226-翻转二叉树-🌟" aria-hidden="true">#</a> 226.翻转二叉树 🌟</h2><p><a href="https://leetcode.cn/problems/invert-binary-tree/description/" target="_blank" rel="noopener noreferrer">力扣链接</a> 🌟</p><h3 id="题目描述"><a class="header-anchor" href="#题目描述" aria-hidden="true">#</a> 题目描述</h3><p>给你一棵二叉树的根节点 root ，翻转这棵二叉树，并返回其根节点。</p><h3 id="解题思路"><a class="header-anchor" href="#解题思路" aria-hidden="true">#</a> 解题思路</h3><p><strong>翻转：将每个节点的左右子节点进行交换</strong></p><ul><li>通常可以用<strong>前序或后序</strong>，因为可以在访问中节点的时候直接交换左右子树</li><li>中序遍历，先处理完左子树之后交换左右，可能会导致原来的左子树被处理两次</li></ul><p>如：</p><div class="language-js"><pre><code><span class="token comment">//       1</span>\n<span class="token comment">//      / \\</span>\n<span class="token comment">//     2   3</span>\n<span class="token comment">//    / \\</span>\n<span class="token comment">//   4   5</span>\n</code></pre></div><ul><li><p>前序遍历：</p><ol><li>处理中间节点 1（交换 2 和 3）</li><li>再处理左节点（此时为 3）</li><li>最后右节点（此时为 2）</li></ol></li><li><p>中序遍历</p><ol><li>处理左子树（节点 4）</li><li>回到中间节点 2，交换左右子树（4 和 5 互换位置）</li><li>处理新的右子树（原左子树 4），导致节点 4 被重复处理，而节点 5 未被处理</li></ol></li></ul><h4 id="递归"><a class="header-anchor" href="#递归" aria-hidden="true">#</a> 递归</h4><div class="language-js"><pre><code><span class="token comment">// 前序遍历</span>\n<span class="token keyword">function</span> <span class="token function">invertTree</span><span class="token punctuation">(</span><span class="token parameter">root</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>root<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token keyword">null</span>\n  <span class="token punctuation">;</span><span class="token punctuation">[</span>root<span class="token punctuation">.</span>right<span class="token punctuation">,</span> root<span class="token punctuation">.</span>left<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">[</span>root<span class="token punctuation">.</span>left<span class="token punctuation">,</span> root<span class="token punctuation">.</span>right<span class="token punctuation">]</span>\n  <span class="token function">invertTree</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>left<span class="token punctuation">)</span>\n  <span class="token function">invertTree</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>right<span class="token punctuation">)</span>\n\n  <span class="token keyword">return</span> root\n<span class="token punctuation">}</span>\n</code></pre></div><h4 id="迭代"><a class="header-anchor" href="#迭代" aria-hidden="true">#</a> 迭代</h4><div class="language-js"><pre><code><span class="token comment">// 统一模板的前序遍历</span>\n<span class="token keyword">function</span> <span class="token function">invertTree</span><span class="token punctuation">(</span><span class="token parameter">root</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>root<span class="token punctuation">)</span> <span class="token keyword">return</span> root\n  <span class="token keyword">const</span> <span class="token function-variable function">invertNode</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token parameter">root<span class="token punctuation">,</span> left<span class="token punctuation">,</span> right</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>\n    <span class="token keyword">const</span> temp <span class="token operator">=</span> right\n    right <span class="token operator">=</span> left\n    left <span class="token operator">=</span> temp\n    root<span class="token punctuation">.</span>left <span class="token operator">=</span> left\n    root<span class="token punctuation">.</span>right <span class="token operator">=</span> right\n  <span class="token punctuation">}</span>\n\n  <span class="token keyword">const</span> stack <span class="token operator">=</span> <span class="token punctuation">[</span>root<span class="token punctuation">]</span>\n\n  <span class="token keyword">while</span> <span class="token punctuation">(</span>stack<span class="token punctuation">.</span>length<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token keyword">let</span> node <span class="token operator">=</span> stack<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span>\n    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>node<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n      node <span class="token operator">=</span> stack<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span>\n      <span class="token function">invertNode</span><span class="token punctuation">(</span>node<span class="token punctuation">,</span> node<span class="token punctuation">.</span>left<span class="token punctuation">,</span> node<span class="token punctuation">.</span>right<span class="token punctuation">)</span>\n    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>\n      node<span class="token punctuation">.</span>right <span class="token operator">&amp;&amp;</span> stack<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>right<span class="token punctuation">)</span>\n      node<span class="token punctuation">.</span>left <span class="token operator">&amp;&amp;</span> stack<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>left<span class="token punctuation">)</span>\n      stack<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>node<span class="token punctuation">)</span>\n      stack<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token keyword">null</span><span class="token punctuation">)</span>\n    <span class="token punctuation">}</span>\n  <span class="token punctuation">}</span>\n  <span class="token keyword">return</span> root\n<span class="token punctuation">}</span>\n</code></pre></div><h4 id="层序"><a class="header-anchor" href="#层序" aria-hidden="true">#</a> 层序</h4><div class="language-js"><pre><code><span class="token keyword">function</span> <span class="token function">invertTree</span><span class="token punctuation">(</span><span class="token parameter">root</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  <span class="token keyword">const</span> <span class="token function-variable function">invertNode</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token parameter">root<span class="token punctuation">,</span> left<span class="token punctuation">,</span> right</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>\n    <span class="token keyword">const</span> temp <span class="token operator">=</span> right\n    right <span class="token operator">=</span> left\n    left <span class="token operator">=</span> temp\n    root<span class="token punctuation">.</span>left <span class="token operator">=</span> left\n    root<span class="token punctuation">.</span>right <span class="token operator">=</span> right\n  <span class="token punctuation">}</span>\n  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>root<span class="token punctuation">)</span> <span class="token keyword">return</span> root\n  <span class="token keyword">const</span> queue <span class="token operator">=</span> <span class="token punctuation">[</span>root<span class="token punctuation">]</span>\n  <span class="token keyword">while</span> <span class="token punctuation">(</span>queue<span class="token punctuation">.</span>length<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token keyword">let</span> node <span class="token operator">=</span> queue<span class="token punctuation">.</span><span class="token function">shift</span><span class="token punctuation">(</span><span class="token punctuation">)</span>\n    <span class="token function">invertNode</span><span class="token punctuation">(</span>node<span class="token punctuation">,</span> node<span class="token punctuation">.</span>left<span class="token punctuation">,</span> node<span class="token punctuation">.</span>right<span class="token punctuation">)</span>\n    node<span class="token punctuation">.</span>left <span class="token operator">&amp;&amp;</span> queue<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>left<span class="token punctuation">)</span>\n    node<span class="token punctuation">.</span>right <span class="token operator">&amp;&amp;</span> queue<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>right<span class="token punctuation">)</span>\n  <span class="token punctuation">}</span>\n  <span class="token keyword">return</span> root\n<span class="token punctuation">}</span>\n</code></pre></div><h2 id="_101-对称二叉树-🌟"><a class="header-anchor" href="#_101-对称二叉树-🌟" aria-hidden="true">#</a> 101. 对称二叉树 🌟</h2><p><a href="https://leetcode.cn/problems/symmetric-tree/description/" target="_blank" rel="noopener noreferrer">力扣链接</a> 🌟</p><h3 id="题目描述-2"><a class="header-anchor" href="#题目描述-2" aria-hidden="true">#</a> 题目描述</h3><p>给定一个二叉树，检查它是否是镜像对称的。</p><h3 id="解题思路-2"><a class="header-anchor" href="#解题思路-2" aria-hidden="true">#</a> 解题思路</h3><ul><li><strong>必须使用后序遍历</strong>：需要先获取左右子树的信息，才能确定当前节点是否满足对称条件</li><li>如果前序遍历：先处理根节点，此时左右节点都还没有处理，那么就无法判断是否对称</li></ul><p>递归三部曲：</p><ol><li><p>确定递归函数的参数和返回值</p><ul><li>参数：比较左右子树是不是对称树，所以参数自然是左子树节点和右子树节点</li><li>返回值：bool</li></ul></li><li><p>确定终止条件</p><p>比较两个节点数值是否相同，一共三种情况：</p><ol><li>左右同时为 null，对称</li><li>一个为 null，另一个不为 null，不对称</li><li>都不为 null，值不想等，不对称</li></ol><div class="language-js"><pre><code><span class="token comment">// 同时为空，对称</span>\n<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>left <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span>right<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token boolean">true</span>\n<span class="token comment">// 一个为空，另一个非空，不对称</span>\n<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>left <span class="token operator">||</span> <span class="token operator">!</span>right<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token boolean">false</span>\n<span class="token comment">// 值不相等，直接返回 false</span>\n<span class="token keyword">if</span> <span class="token punctuation">(</span>left<span class="token punctuation">.</span>val <span class="token operator">!==</span> right<span class="token punctuation">.</span>val<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token boolean">false</span>\n</code></pre></div></li><li><p>确定单层递归逻辑</p><ul><li>比较左节点的左孩子和右节点的右孩子 <code>compare(left.left, right.right)</code></li><li>以及左节点的右孩子和右节点的左孩子 <code>compare(left.right, right.left)</code></li><li>同时为 true，则相等</li></ul></li></ol><h3 id="代码"><a class="header-anchor" href="#代码" aria-hidden="true">#</a> 代码</h3><h4 id="递归-2"><a class="header-anchor" href="#递归-2" aria-hidden="true">#</a> 递归</h4><div class="language-js"><pre><code><span class="token keyword">function</span> <span class="token function">isSymmetric</span><span class="token punctuation">(</span><span class="token parameter">root</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>root<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token boolean">true</span>\n\n  <span class="token keyword">const</span> <span class="token function-variable function">compare</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token parameter">left<span class="token punctuation">,</span> right</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>\n    <span class="token comment">// 左右都为null</span>\n    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>left <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span>right<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token boolean">true</span>\n    <span class="token comment">// 左右一个为null</span>\n    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>left <span class="token operator">||</span> <span class="token operator">!</span>right<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token boolean">false</span>\n    <span class="token comment">// 左右都不为null，值不想等</span>\n    <span class="token keyword">if</span> <span class="token punctuation">(</span>left<span class="token punctuation">.</span>val <span class="token operator">!==</span> right<span class="token punctuation">.</span>val<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token boolean">false</span>\n\n    <span class="token keyword">return</span> <span class="token function">compare</span><span class="token punctuation">(</span>left<span class="token punctuation">.</span>left<span class="token punctuation">,</span> right<span class="token punctuation">.</span>right<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token function">compare</span><span class="token punctuation">(</span>left<span class="token punctuation">.</span>right<span class="token punctuation">,</span> right<span class="token punctuation">.</span>left<span class="token punctuation">)</span>\n  <span class="token punctuation">}</span>\n\n  <span class="token keyword">return</span> <span class="token function">compare</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>left<span class="token punctuation">,</span> root<span class="token punctuation">.</span>right<span class="token punctuation">)</span>\n<span class="token punctuation">}</span>\n</code></pre></div><h4 id="迭代-2"><a class="header-anchor" href="#迭代-2" aria-hidden="true">#</a> 迭代</h4><div class="language-js"><pre><code><span class="token keyword">function</span> <span class="token function">isSymmetric</span><span class="token punctuation">(</span><span class="token parameter">root</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>root<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token boolean">true</span>\n  <span class="token keyword">const</span> stack <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>\n  stack<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>left<span class="token punctuation">)</span>\n  stack<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>right<span class="token punctuation">)</span>\n\n  <span class="token keyword">while</span> <span class="token punctuation">(</span>stack<span class="token punctuation">.</span>length<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token keyword">let</span> left <span class="token operator">=</span> stack<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span>\n    <span class="token keyword">let</span> right <span class="token operator">=</span> stack<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span>\n    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>left <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span>right<span class="token punctuation">)</span> <span class="token keyword">continue</span>\n    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>left <span class="token operator">||</span> <span class="token operator">!</span>right <span class="token operator">||</span> left<span class="token punctuation">.</span>val <span class="token operator">!==</span> right<span class="token punctuation">.</span>val<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n      <span class="token keyword">return</span> <span class="token boolean">false</span>\n    <span class="token punctuation">}</span>\n\n    stack<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>left<span class="token punctuation">.</span>left<span class="token punctuation">)</span>\n    stack<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>right<span class="token punctuation">.</span>right<span class="token punctuation">)</span>\n    stack<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>left<span class="token punctuation">.</span>right<span class="token punctuation">)</span>\n    stack<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>right<span class="token punctuation">.</span>left<span class="token punctuation">)</span>\n  <span class="token punctuation">}</span>\n\n  <span class="token keyword">return</span> <span class="token boolean">true</span>\n<span class="token punctuation">}</span>\n</code></pre></div><h2 id="二叉树的最大深度"><a class="header-anchor" href="#二叉树的最大深度" aria-hidden="true">#</a> 二叉树的最大深度</h2><p><a href="https://leetcode.cn/problems/maximum-depth-of-binary-tree/description/" target="_blank" rel="noopener noreferrer">力扣链接</a></p><h3 id="题目描述-3"><a class="header-anchor" href="#题目描述-3" aria-hidden="true">#</a> 题目描述</h3><p>给定一个二叉树 root ，返回其最大深度。</p><p>二叉树的 最大深度 是指从根节点到最远叶子节点的最长路径上的节点数。</p><p>说明: 叶子节点是指没有子节点的节点。</p><p>示例： 给定二叉树 [3,9,20,null,null,15,7]，</p><div class="language-js"><pre><code><span class="token comment">//       3</span>\n<span class="token comment">//      / \\</span>\n<span class="token comment">//     9  20</span>\n<span class="token comment">//       / \\</span>\n<span class="token comment">//      15 7</span>\n</code></pre></div><p>返回它的最大深度 3</p><h3 id="解题思路-3"><a class="header-anchor" href="#解题思路-3" aria-hidden="true">#</a> 解题思路</h3><ul><li>二叉树节点深度：从根节点到该节点的路径长度</li><li>二叉树节点高度：指从该节点到叶子节点的最长路径</li></ul><h4 id="遍历方式"><a class="header-anchor" href="#遍历方式" aria-hidden="true">#</a> 遍历方式</h4><ul><li><p>二叉树节点深度</p><p>使用前序遍历 <code>中 -&gt; 左 -&gt; 右</code>，节点的深度由其父节点的深度决定（<strong>深度 = 父节点深度 + 1</strong>）。在遍历时，需要先访问当前节点（记录其深度），再递归处理子节点。</p></li><li><p>二叉树节点高度</p><p>使用后序遍历 <code>左 -&gt; 右 -&gt; 中</code>，节点的高度取决于其左右子树的高度。必须先知道左右子树的高度，才能计算当前节点的高度（<strong>当前高度 = max(左子树高度, 右子树高度) + 1</strong>）。</p></li></ul><p><strong>根节点的高度就是二叉树的最大深度</strong></p><h4 id="递归三部曲"><a class="header-anchor" href="#递归三部曲" aria-hidden="true">#</a> 递归三部曲</h4><ol><li><p>确定递归函数的参数和返回值</p><ul><li>参数：当前节点</li><li>返回值：当前树的高度</li></ul></li><li><p>确定终止条件</p><ul><li>节点为 null ，返回高度为 0</li></ul></li><li><p>确定单层递归逻辑</p><ul><li>求左子树高度</li><li>求右子树高度</li><li>返回左右子树高度的较大值 + 1</li></ul></li></ol><h3 id="代码-2"><a class="header-anchor" href="#代码-2" aria-hidden="true">#</a> 代码</h3><h4 id="递归-3"><a class="header-anchor" href="#递归-3" aria-hidden="true">#</a> 递归</h4><div class="language-js"><pre><code><span class="token keyword">function</span> <span class="token function">maxDepth</span><span class="token punctuation">(</span><span class="token parameter">root</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>root<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token number">0</span>\n  <span class="token keyword">return</span> Math<span class="token punctuation">.</span><span class="token function">max</span><span class="token punctuation">(</span><span class="token function">maxDepth</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>left<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">maxDepth</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>right<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1</span>\n<span class="token punctuation">}</span>\n</code></pre></div><h4 id="迭代-3"><a class="header-anchor" href="#迭代-3" aria-hidden="true">#</a> 迭代</h4><div class="language-js"><pre><code><span class="token keyword">function</span> <span class="token function">maxDepth</span><span class="token punctuation">(</span><span class="token parameter">root</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>root<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token number">0</span>\n  <span class="token keyword">let</span> queue <span class="token operator">=</span> <span class="token punctuation">[</span>root<span class="token punctuation">]</span>\n  <span class="token keyword">let</span> depth <span class="token operator">=</span> <span class="token number">0</span>\n  <span class="token keyword">while</span> <span class="token punctuation">(</span>queue<span class="token punctuation">.</span>length<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    depth<span class="token operator">++</span>\n    <span class="token keyword">let</span> len <span class="token operator">=</span> queue<span class="token punctuation">.</span>length\n    <span class="token keyword">while</span> <span class="token punctuation">(</span>len<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n      <span class="token keyword">const</span> node <span class="token operator">=</span> queue<span class="token punctuation">.</span><span class="token function">shift</span><span class="token punctuation">(</span><span class="token punctuation">)</span>\n      node<span class="token punctuation">.</span>left <span class="token operator">&amp;&amp;</span> queue<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>left<span class="token punctuation">)</span>\n      node<span class="token punctuation">.</span>right <span class="token operator">&amp;&amp;</span> queue<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>right<span class="token punctuation">)</span>\n      len<span class="token operator">--</span>\n    <span class="token punctuation">}</span>\n  <span class="token punctuation">}</span>\n  <span class="token keyword">return</span> depth\n<span class="token punctuation">}</span>\n</code></pre></div><h2 id="二叉树的最小深度"><a class="header-anchor" href="#二叉树的最小深度" aria-hidden="true">#</a> 二叉树的最小深度</h2><p><a href="https://leetcode.cn/problems/minimum-depth-of-binary-tree/description/" target="_blank" rel="noopener noreferrer">力扣链接</a></p><h3 id="题目描述-4"><a class="header-anchor" href="#题目描述-4" aria-hidden="true">#</a> 题目描述</h3><p>给定一个二叉树，找出其最小深度。</p><p>最小深度是从根节点到最近叶子节点的最短路径上的节点数量。</p><p>说明: 叶子节点是指没有子节点的节点。</p><p>示例:</p><p>给定二叉树 [3,9,20,null,null,15,7],</p><div class="language-js"><pre><code><span class="token comment">//       3</span>\n<span class="token comment">//      / \\</span>\n<span class="token comment">//     9  20</span>\n<span class="token comment">//       / \\</span>\n<span class="token comment">//      15 7</span>\n</code></pre></div><p>返回它的最大深度 2</p><h3 id="解题思路-4"><a class="header-anchor" href="#解题思路-4" aria-hidden="true">#</a> 解题思路</h3><ul><li>二叉树节点深度：指从根节点到该节点的最长简单路径边的节点数</li><li>二叉树节点高度：指从该节点到叶子节点的最长简单路径边的节点数</li></ul><p><strong>根节点的高度就是二叉树的最大深度</strong></p><h4 id="递归三部曲-2"><a class="header-anchor" href="#递归三部曲-2" aria-hidden="true">#</a> 递归三部曲</h4><ol><li><p>确定递归函数的参数和返回值</p><ul><li>参数：当前节点</li><li>返回值：当前树的高度</li></ul></li><li><p>确定终止条件</p><ul><li>节点为 null ，返回高度为 0</li></ul></li><li><p>确定单层递归逻辑</p><ul><li>求左子树高度</li><li>求右子树高度</li><li>左子树为空，右子树不为空，返回右子树高度 + 1</li><li>右子树为空，左子树不为空，返回左子树高度 + 1</li><li>左右子树都不为空，返回左右子树高度的较小值 + 1</li></ul></li></ol><h3 id="代码-3"><a class="header-anchor" href="#代码-3" aria-hidden="true">#</a> 代码</h3><h4 id="递归-4"><a class="header-anchor" href="#递归-4" aria-hidden="true">#</a> 递归</h4><div class="language-js"><pre><code><span class="token keyword">function</span> <span class="token function">minDepth</span><span class="token punctuation">(</span><span class="token parameter">root</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>root<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token number">0</span>\n  <span class="token comment">// 到叶子节点 返回 1</span>\n  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>root<span class="token punctuation">.</span>left <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span>root<span class="token punctuation">.</span>right<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token number">1</span>\n  <span class="token comment">// 只有右节点时 递归右节点</span>\n  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>root<span class="token punctuation">.</span>left<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token number">1</span> <span class="token operator">+</span> <span class="token function">minDepth</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>right<span class="token punctuation">)</span>\n  <span class="token comment">// 只有左节点时 递归左节点</span>\n  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>root<span class="token punctuation">.</span>right<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token number">1</span> <span class="token operator">+</span> <span class="token function">minDepth</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>left<span class="token punctuation">)</span>\n  <span class="token keyword">return</span> Math<span class="token punctuation">.</span><span class="token function">min</span><span class="token punctuation">(</span><span class="token function">minDepth</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>left<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">minDepth</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>right<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1</span>\n<span class="token punctuation">}</span>\n</code></pre></div><h4 id="迭代-4"><a class="header-anchor" href="#迭代-4" aria-hidden="true">#</a> 迭代</h4><div class="language-js"><pre><code><span class="token keyword">function</span> <span class="token function">minDepth</span><span class="token punctuation">(</span><span class="token parameter">root</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  <span class="token keyword">if</span> <span class="token punctuation">(</span>root <span class="token operator">===</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token number">0</span>\n  <span class="token keyword">let</span> queue <span class="token operator">=</span> <span class="token punctuation">[</span>root<span class="token punctuation">]</span>\n  <span class="token keyword">let</span> depth <span class="token operator">=</span> <span class="token number">0</span>\n  <span class="token keyword">while</span> <span class="token punctuation">(</span>queue<span class="token punctuation">.</span>length<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token keyword">let</span> length <span class="token operator">=</span> queue<span class="token punctuation">.</span>length\n    depth<span class="token operator">++</span>\n    <span class="token keyword">while</span> <span class="token punctuation">(</span>length<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n      <span class="token keyword">const</span> node <span class="token operator">=</span> queue<span class="token punctuation">.</span><span class="token function">shift</span><span class="token punctuation">(</span><span class="token punctuation">)</span>\n\n      <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>node<span class="token punctuation">.</span>left <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span>node<span class="token punctuation">.</span>right<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n        <span class="token keyword">return</span> depth\n      <span class="token punctuation">}</span>\n\n      node<span class="token punctuation">.</span>left <span class="token operator">&amp;&amp;</span> queue<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>left<span class="token punctuation">)</span>\n      node<span class="token punctuation">.</span>right <span class="token operator">&amp;&amp;</span> queue<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>right<span class="token punctuation">)</span>\n      length<span class="token operator">--</span>\n    <span class="token punctuation">}</span>\n  <span class="token punctuation">}</span>\n  <span class="token keyword">return</span> depth\n<span class="token punctuation">}</span>\n</code></pre></div>',70)];p.render=function(a,t,p,e,c,l){return n(),s("div",null,o)};export{t as __pageData,p as default};
