import{f as n,g as s,J as a}from"./common-03e46d7f.js";const p='{"title":"跟着卡哥学算法Day 31：贪心算法part5","frontmatter":{"date":"2025-03-14","title":"跟着卡哥学算法Day 31：贪心算法part5","tags":["leetcode"],"describe":"贪心算法part5"},"headers":[{"level":2,"title":"56. 合并区间 🌟🌟","slug":"_56-合并区间-🌟🌟"},{"level":3,"title":"题目描述","slug":"题目描述"},{"level":3,"title":"解题思路","slug":"解题思路"},{"level":2,"title":"738.单调递增的数字 🌟🌟","slug":"_738-单调递增的数字-🌟🌟"},{"level":3,"title":"题目描述","slug":"题目描述-2"},{"level":3,"title":"解题思路","slug":"解题思路-2"},{"level":2,"title":"968.监控二叉树 🌟🌟🌟","slug":"_968-监控二叉树-🌟🌟🌟"},{"level":3,"title":"题目描述","slug":"题目描述-3"},{"level":3,"title":"解题思路","slug":"解题思路-3"}],"relativePath":"docs/leetcode/greedy-algorithmc-code5.md","lastUpdated":1742523053375.6387}';var t={};const o=[a('<h2 id="_56-合并区间-🌟🌟"><a class="header-anchor" href="#_56-合并区间-🌟🌟" aria-hidden="true">#</a> 56. 合并区间 🌟🌟</h2><p><a href="https://leetcode.cn/problems/merge-intervals/description/" target="_blank" rel="noopener noreferrer">力扣链接</a> 🌟🌟</p><h3 id="题目描述"><a class="header-anchor" href="#题目描述" aria-hidden="true">#</a> 题目描述</h3><p>给出一个区间的集合，请合并所有重叠的区间。</p><p>示例 1:</p><ul><li>输入: intervals = [[1,3],[2,6],[8,10],[15,18]]</li><li>输出: [[1,6],[8,10],[15,18]]</li><li>解释: 区间 [1,3] 和 [2,6] 重叠, 将它们合并为 [1,6].</li></ul><p>示例  2:</p><ul><li>输入: intervals = [[1,4],[4,5]]</li><li>输出: [[1,5]]</li><li>解释: 区间 [1,4] 和 [4,5] 可被视为重叠区间。</li><li>注意：输入类型已于 2019 年 4 月 15 日更改。 请重置默认代码定义以获取新方法签名。</li></ul><h3 id="解题思路"><a class="header-anchor" href="#解题思路" aria-hidden="true">#</a> 解题思路</h3><p>类似上篇 <a href="./greedy-algorithmc-code4.md/#452-用最少数量的箭引爆气球-">452. 用最少数量的箭引爆气球</a>和<a href="./greedy-algorithmc-code4.md/#435-无重叠区间-">435. 无重叠区间</a></p><p>题解：</p><ol><li>按起始点从小到大排序</li><li>如果 <code>intervals[i][0] &lt;= intervals[i - 1][1]</code>，即当前左边界小于上一个右边界，则一定有重叠</li><li>合并区间，更新右边界为 <code>Math.max(intervals[i][1], intervals[i - 1][1])</code>，合并为 <code>[intervals[i - 1][0], max(intervals[i - 1][1], intervals[i][1])]</code></li><li>没有重叠，则直接添加进数组</li></ol><div class="language-js"><pre><code><span class="token keyword">var</span> <span class="token function-variable function">merge</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">intervals</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  intervals<span class="token punctuation">.</span><span class="token function">sort</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">a<span class="token punctuation">,</span> b</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> a<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">-</span> b<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span>\n  <span class="token keyword">const</span> result <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>\n  <span class="token comment">// 初始化前一个区间为排序后的第一个区间</span>\n  <span class="token keyword">let</span> preInterval <span class="token operator">=</span> intervals<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span>\n  <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> intervals<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token keyword">const</span> curInterval <span class="token operator">=</span> intervals<span class="token punctuation">[</span>i<span class="token punctuation">]</span>\n\n    <span class="token comment">// 判断当前区间是否与前一个区间重叠</span>\n    <span class="token keyword">if</span> <span class="token punctuation">(</span>curInterval<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">&lt;=</span> preInterval<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n      <span class="token comment">// 合并区间：更新前一个区间的结束点为两者中的较大值</span>\n      preInterval<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> Math<span class="token punctuation">.</span><span class="token function">max</span><span class="token punctuation">(</span>curInterval<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span> preInterval<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span>\n    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>\n      <span class="token comment">// 无重叠时，将前一个区间加入结果，并更新为当前区间</span>\n      result<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>preInterval<span class="token punctuation">)</span>\n      preInterval <span class="token operator">=</span> curInterval\n    <span class="token punctuation">}</span>\n  <span class="token punctuation">}</span>\n\n  <span class="token comment">// 将最后一个合并后的区间加入结果</span>\n  result<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>preInterval<span class="token punctuation">)</span>\n  <span class="token keyword">return</span> result\n<span class="token punctuation">}</span>\n</code></pre></div><h4 id="示例"><a class="header-anchor" href="#示例" aria-hidden="true">#</a> 示例</h4><p>输入：<code>[[1,3],[2,6],[8,10],[15,18]]</code><br> 执行过程：</p><ol><li>排序后顺序不变</li><li>合并 <code>[1,3]</code> 和 <code>[2,6]</code> → <code>[1,6]</code></li><li><code>[8,10]</code> 与前一个区间无重叠，<code>[1,6]</code>加入结果</li><li><code>[15,18]</code> 无重叠，<code>[8,10]</code>加入结果</li><li><code>[15,18]</code>加入结果</li></ol><p>输出：<code>[[1,6],[8,10],[15,18]]</code></p><h2 id="_738-单调递增的数字-🌟🌟"><a class="header-anchor" href="#_738-单调递增的数字-🌟🌟" aria-hidden="true">#</a> 738.单调递增的数字 🌟🌟</h2><p><a href="https://leetcode.cn/problems/monotone-increasing-digits/" target="_blank" rel="noopener noreferrer">力扣链接</a> 🌟🌟</p><h3 id="题目描述-2"><a class="header-anchor" href="#题目描述-2" aria-hidden="true">#</a> 题目描述</h3><p>给定一个非负整数  N，找出小于或等于  N  的最大的整数，同时这个整数需要满足其各个位数上的数字是单调递增。</p><p>（当且仅当每个相邻位数上的数字  x  和  y  满足  x &lt;= y  时，我们称这个整数是单调递增的。）</p><p>示例 1:</p><ul><li>输入: N = 10</li><li>输出: 9</li></ul><p>示例 2:</p><ul><li>输入: N = 1234</li><li>输出: 1234</li></ul><p>示例 3:</p><ul><li>输入: N = 332</li><li>输出: 299</li></ul><p>说明: N  是在  [0, 10^9]  范围内的一个整数。</p><h3 id="解题思路-2"><a class="header-anchor" href="#解题思路-2" aria-hidden="true">#</a> 解题思路</h3><h4 id="暴力法"><a class="header-anchor" href="#暴力法" aria-hidden="true">#</a> 暴力法</h4><p>从当前数字递减，挨个判断是否为递增</p><div class="language-js"><pre><code><span class="token comment">// 判断一个数字的各位上是否是递增</span>\n<span class="token keyword">const</span> <span class="token function-variable function">checkNum</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token parameter">num</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>\n  <span class="token keyword">let</span> max <span class="token operator">=</span> <span class="token number">10</span>\n  <span class="token keyword">while</span> <span class="token punctuation">(</span>num<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token keyword">let</span> t <span class="token operator">=</span> num <span class="token operator">%</span> <span class="token number">10</span>\n    <span class="token keyword">if</span> <span class="token punctuation">(</span>max <span class="token operator">&gt;=</span> t<span class="token punctuation">)</span> max <span class="token operator">=</span> t\n    <span class="token keyword">else</span> <span class="token keyword">return</span> <span class="token boolean">false</span>\n    num <span class="token operator">=</span> Math<span class="token punctuation">.</span><span class="token function">floor</span><span class="token punctuation">(</span>num <span class="token operator">/</span> <span class="token number">10</span><span class="token punctuation">)</span>\n  <span class="token punctuation">}</span>\n  <span class="token keyword">return</span> <span class="token boolean">true</span>\n<span class="token punctuation">}</span>\n\n<span class="token keyword">const</span> <span class="token function-variable function">monotoneIncreasingDigits</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token parameter"><span class="token constant">N</span></span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>\n  <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token constant">N</span><span class="token punctuation">;</span> i <span class="token operator">&gt;</span> <span class="token number">0</span><span class="token punctuation">;</span> i<span class="token operator">--</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token comment">// 从大到小遍历</span>\n    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">checkNum</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">return</span> i\n  <span class="token punctuation">}</span>\n  <span class="token keyword">return</span> <span class="token number">0</span>\n<span class="token punctuation">}</span>\n</code></pre></div><h4 id="贪心法"><a class="header-anchor" href="#贪心法" aria-hidden="true">#</a> 贪心法</h4><p>举例：如果 N=98，一旦出现 num[i - 1] &gt; num[i]时，首先给 num[i-1]--，然后 num[i]给为 9，这个数就是 89，满足最大的单调递增整数。</p><p><strong>遍历方式如何确定？</strong></p><ol><li>思考如果从前往后遍历，遇到 <code>num[i - 1] &gt; num[i]</code> 时，如果让 <code>num[i - 1]--</code>，此时可能出现 <code>num[i - 1] &lt; num[i - 2]</code>，如数字 332，从前往后遍历会变为 329，不符合</li><li>从后往前遍历，遇到 <code>num[i] &lt; num[i + 1]</code> 时，如果让 <code>num[i]--</code>，此时不会影响前面的数字，如数字 332，从后往前遍历先变为 329，继续遍历为 299，符合</li></ol><p><strong>注意：找到最前面是递减的位置，然后让这个位置的数减一，后面位置都为 9，这样保证数值尽可能大</strong></p><p>如：100，从后往前遍历，找到递减的位置为 1，后面位置都为 9，即为 99</p><div class="language-js"><pre><code><span class="token keyword">var</span> <span class="token function-variable function">monotoneIncreasingDigits</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">n</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  n <span class="token operator">=</span> n\n    <span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span>\n    <span class="token punctuation">.</span><span class="token function">split</span><span class="token punctuation">(</span><span class="token string">&#39;&#39;</span><span class="token punctuation">)</span>\n    <span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">item</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token operator">+</span>item<span class="token punctuation">)</span>\n\n  <span class="token keyword">const</span> len <span class="token operator">=</span> n<span class="token punctuation">.</span>length\n  <span class="token comment">// 第一个递减的位置flag</span>\n  <span class="token keyword">let</span> flag <span class="token operator">=</span> <span class="token number">Infinity</span>\n  <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> len <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&gt;</span> <span class="token number">0</span><span class="token punctuation">;</span> i<span class="token operator">--</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token keyword">if</span> <span class="token punctuation">(</span>n<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">&gt;</span> n<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n      flag <span class="token operator">=</span> i\n      n<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token operator">--</span>\n      n<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">9</span>\n    <span class="token punctuation">}</span>\n  <span class="token punctuation">}</span>\n  <span class="token comment">// 将flag 之后的所有位设为9，保证数值尽可能大</span>\n  <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> flag<span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    n<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">9</span>\n  <span class="token punctuation">}</span>\n\n  <span class="token keyword">return</span> <span class="token operator">+</span>n<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token string">&#39;&#39;</span><span class="token punctuation">)</span>\n<span class="token punctuation">}</span>\n</code></pre></div><h2 id="_968-监控二叉树-🌟🌟🌟"><a class="header-anchor" href="#_968-监控二叉树-🌟🌟🌟" aria-hidden="true">#</a> 968.监控二叉树 🌟🌟🌟</h2><p><a href="https://leetcode.cn/problems/binary-tree-cameras/description/" target="_blank" rel="noopener noreferrer">力扣链接</a> 🌟🌟🌟</p><h3 id="题目描述-3"><a class="header-anchor" href="#题目描述-3" aria-hidden="true">#</a> 题目描述</h3><p>给定一个二叉树，我们在树的节点上安装摄像头。</p><p>节点上的每个摄影头都可以监视其父对象、自身及其直接子对象。</p><p>计算监控树的所有节点所需的最小摄像头数量。</p><p>示例 1：</p><p><img src="/blog/_assets/greedy-algorithmc-code51.bbc7ae94.png" alt="greedy-algorithmc-code5"></p><ul><li>输入：[0,0,null,0,0]</li><li>输出：1</li><li>解释：如图所示，一台摄像头足以监控所有节点。</li></ul><p>示例 2：</p><p><img src="/blog/_assets/greedy-algorithmc-code52.b5d1d733.png" alt="greedy-algorithmc-code5"></p><ul><li>输入：[0,0,null,0,null,0,null,null,0]</li><li>输出：2</li><li>解释：需要至少两个摄像头来监视树的所有节点。 上图显示了摄像头放置的有效位置之一。</li></ul><p>提示：</p><ul><li>给定树的节点数的范围是 [1, 1000]。</li><li>每个节点的值都是 0。</li></ul><h3 id="解题思路-3"><a class="header-anchor" href="#解题思路-3" aria-hidden="true">#</a> 解题思路</h3><p>二叉树与贪心法的结合 ❗️❗️❗️</p><h4 id="如何放置摄像头？"><a class="header-anchor" href="#如何放置摄像头？" aria-hidden="true">#</a> 如何放置摄像头？</h4><ul><li><p>摄像头覆盖上中下三层</p></li><li><p>摄像头不会放在头节点，浪费一个</p></li><li><p>摄像头不会放在叶子节点，浪费一堆</p></li><li><p>摄像头放在叶子节点的父节点，充分利用摄像头</p></li><li><p>应使用后序遍历</p><div class="language-js"><pre><code><span class="token keyword">function</span> <span class="token function">traverse</span><span class="token punctuation">(</span><span class="token parameter">root</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>root<span class="token punctuation">)</span> <span class="token keyword">return</span>\n\n  <span class="token function">traverse</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>left<span class="token punctuation">)</span>\n  <span class="token function">traverse</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>right<span class="token punctuation">)</span>\n\n  <span class="token comment">// 处理中间节点</span>\n<span class="token punctuation">}</span>\n</code></pre></div></li></ul><p><strong>局部最优：让叶子节点的父节点安装摄像头，所有摄像头最少</strong><strong>全局最优：放置最少的摄像头</strong></p><h4 id="如何隔两个节点放一个摄像头"><a class="header-anchor" href="#如何隔两个节点放一个摄像头" aria-hidden="true">#</a> 如何隔两个节点放一个摄像头</h4><p>需要状态转移，首先有三种状态：</p><ul><li>0: 该节点无覆盖</li><li>1: 该节点被覆盖，但没有安装摄像头</li><li>2: 该节点被覆盖，且安装摄像头</li></ul><p>为使摄像头最少，应该叶子节点的父节点安装摄像头，那么<strong>空节点就应该是有覆盖状态</strong></p><ul><li><p>如果空节点为无覆盖状态，那么叶子节点需要放置摄像头</p></li><li><p>如果空节点为有摄像头状态，那么叶子节点的父节点就没必要放置摄像头</p></li><li><p>递归的终止条件</p><div class="language-js"><pre><code><span class="token comment">// 空节点，有覆盖</span>\n<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>cur<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token number">1</span>\n</code></pre></div></li><li><p>单层处理逻辑</p><ul><li><p>情况 1：左右节点都有覆盖</p><p>左右孩子都有覆盖，那么此时中间节点就应该是无覆盖状态</p><div class="language-js"><pre><code><span class="token keyword">if</span> <span class="token punctuation">(</span>left <span class="token operator">===</span> <span class="token number">1</span> <span class="token operator">&amp;&amp;</span> right <span class="token operator">===</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token number">0</span>\n</code></pre></div></li><li><p>左右节点至少一个无覆盖状态</p><p>中间节点必须安装摄像头</p><div class="language-js"><pre><code><span class="token keyword">if</span> <span class="token punctuation">(</span>left <span class="token operator">===</span> <span class="token number">0</span> <span class="token operator">||</span> right <span class="token operator">===</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  result<span class="token operator">++</span>\n  <span class="token keyword">return</span> <span class="token number">2</span>\n<span class="token punctuation">}</span>\n</code></pre></div></li><li><p>左右节点至少一个有摄像头</p><p>此时中间节点应该是有覆盖状态</p><div class="language-js"><pre><code><span class="token keyword">if</span> <span class="token punctuation">(</span>left <span class="token operator">===</span> <span class="token number">2</span> <span class="token operator">||</span> right <span class="token operator">===</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token number">1</span>\n</code></pre></div></li><li><p>头节点无覆盖状态</p><p>递归结束后，需要判断根节点覆盖状态，如果无覆盖，则 result++</p><div class="language-js"><pre><code><span class="token keyword">if</span> <span class="token punctuation">(</span>root <span class="token operator">===</span> <span class="token number">0</span><span class="token punctuation">)</span> result<span class="token operator">++</span>\n</code></pre></div></li></ul></li></ul><div class="language-js"><pre><code><span class="token keyword">var</span> <span class="token function-variable function">minCameraCover</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">root</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  <span class="token keyword">let</span> result <span class="token operator">=</span> <span class="token number">0</span>\n  <span class="token keyword">const</span> <span class="token function-variable function">traverse</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token parameter">cur</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>\n    <span class="token comment">// 空节点，该节点有覆盖</span>\n    <span class="token keyword">if</span> <span class="token punctuation">(</span>cur <span class="token operator">===</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token number">1</span>\n\n    <span class="token keyword">let</span> left <span class="token operator">=</span> <span class="token function">traverse</span><span class="token punctuation">(</span>cur<span class="token punctuation">.</span>left<span class="token punctuation">)</span>\n    <span class="token keyword">let</span> right <span class="token operator">=</span> <span class="token function">traverse</span><span class="token punctuation">(</span>cur<span class="token punctuation">.</span>right<span class="token punctuation">)</span>\n    <span class="token comment">// 左右节点都被覆盖</span>\n    <span class="token keyword">if</span> <span class="token punctuation">(</span>left <span class="token operator">===</span> <span class="token number">1</span> <span class="token operator">&amp;&amp;</span> right <span class="token operator">===</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token number">0</span>\n    <span class="token comment">// 至少一个无覆盖</span>\n    <span class="token keyword">if</span> <span class="token punctuation">(</span>left <span class="token operator">===</span> <span class="token number">0</span> <span class="token operator">||</span> right <span class="token operator">===</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n      result<span class="token operator">++</span>\n      <span class="token keyword">return</span> <span class="token number">2</span>\n    <span class="token punctuation">}</span>\n    <span class="token comment">// 至少一个有摄像头</span>\n    <span class="token keyword">if</span> <span class="token punctuation">(</span>left <span class="token operator">===</span> <span class="token number">2</span> <span class="token operator">||</span> right <span class="token operator">===</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token number">1</span>\n  <span class="token punctuation">}</span>\n\n  <span class="token comment">// 根节点无覆盖状态</span>\n  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">traverse</span><span class="token punctuation">(</span>root<span class="token punctuation">)</span> <span class="token operator">===</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    result<span class="token operator">++</span>\n  <span class="token punctuation">}</span>\n\n  <span class="token keyword">return</span> result\n<span class="token punctuation">}</span>\n</code></pre></div>',65)];t.render=function(a,p,t,e,c,l){return n(),s("div",null,o)};export{p as __pageData,t as default};
